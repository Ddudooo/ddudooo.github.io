<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programmings on 공부한 내용 기록용</title>
    <link>/programming/</link>
    <description>Recent content in Programmings on 공부한 내용 기록용</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Mon, 28 Jun 2021 15:55:24 +0900</lastBuildDate><atom:link href="/programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>커맨드 패턴</title>
      <link>/programming/design-pattern/%EC%BB%A4%EB%A7%A8%EB%93%9C-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 28 Jun 2021 15:55:24 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%BB%A4%EB%A7%A8%EB%93%9C-%ED%8C%A8%ED%84%B4/</guid>
      <description>커맨드 패턴이란?  요청을 객체의 형태로 캡슐화하여 사용자가 보낸 요청을 나중에 이용할 수 있도록
매서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴
 HEAD FIRST DESIGN 에서&amp;hellip;  커맨드 객체는 일련의 행동을 특정 리시버하고 연결시킴으로써 요구 사항을 캡슐화한 것이라는 점을 이미 배웠습니다.
이렇게 하기 위해서 행동과 리시버를 한 객체에 집어넣고, execute()라는 메소드 하나만 외부에 공개하는 방법을 씁니다.
이 메소드 호출에 의해서 리시버에서 일련의 작업이 처리됩니다.</description>
      <content>&lt;h2 id=&#34;커맨드-패턴이란&#34;&gt;커맨드 패턴이란?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;요청을 객체의 형태로 캡슐화하여 사용자가 보낸 요청을 나중에 이용할 수 있도록&lt;/p&gt;
&lt;p&gt;매서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;head-first-design-에서&#34;&gt;HEAD FIRST DESIGN 에서&amp;hellip;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;커맨드 객체는 일련의 행동을 특정 리시버하고 연결시킴으로써 요구 사항을 캡슐화한 것이라는 점을 이미 배웠습니다.&lt;/p&gt;
&lt;p&gt;이렇게 하기 위해서 행동과 리시버를 한 객체에 집어넣고, execute()라는 메소드 하나만 외부에 공개하는 방법을 씁니다.&lt;/p&gt;
&lt;p&gt;이 메소드 호출에 의해서 리시버에서 일련의 작업이 처리됩니다.&lt;/p&gt;
&lt;p&gt;외부에서 볼 때는 어떤 객체가 리시버 역할을 하는지, 그 리시버에서 실제로 어떤 일을 하는지 알 수 없습니다.&lt;/p&gt;
&lt;p&gt;그냥 execute() 메소드를 호출하면 요구 사항이 처리된다는 것만 알 수 있을 뿐이죠.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/command/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Command&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;실행될 기능에 대한 인터페이스&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteCommand&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;실제로 실행되는 기능을 구현&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Invoker&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;기능의 실행을 요청하는 호출자 클래스&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;ConcreteCommand&lt;/code&gt;에서 &lt;code&gt;execute&lt;/code&gt; 메서드를 구현할 때 필요한 클래스&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;작업을 요청하는 클래스와 실제로 작업을 수행하는 클래스를 분리하여 시스템의 결합도를 낮출 수 있음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기존 코드를 수정하지 않고 새로운 기능을 비교적 쉽게 추가할 수 있음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동작자체를 객체화하여 일련의 트랜잭션을 객체단위로 제공할 수 있음&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;구현 및 유지보수해야 하는 클래스가 많아지게 됨.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://johngrib.github.io/wiki/command-pattern/&#34;&gt;기계인간 John Grib Command Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/behavioral/CommandPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>브릿지 패턴</title>
      <link>/programming/design-pattern/%EB%B8%8C%EB%A6%BF%EC%A7%80-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Fri, 25 Jun 2021 17:17:15 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EB%B8%8C%EB%A6%BF%EC%A7%80-%ED%8C%A8%ED%84%B4/</guid>
      <description>브릿지 패턴이란?  구현부와 추상층을 분리한 패턴
구현 뿐만 아니라 추상화 부분까지 변경시켜야 하는 경우에 사용하는 구조적 디자인 패턴.
 구조  Abstraction 추상화된 인터페이스 RefinedAbstraction 정의된 인터페이스를 확장하는 객체 Implementor 구현 클래스의 인터페이스를 정의
Abstraction의 인터페이스와 일치 할 필요는 없다. ConcreteImplementor Implementor의 인터페이스를 구현하고 구체적인 구현한 객체  장점  구현을 인터페이스에 완전히 결합시키지 않음
-&amp;gt; 구현과 추상화된 부분을 분리시킬 수 있음. 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있음 추상화된 부분을 구현한 구상 클래스를 바꿔도 클라이언트에 영향을 끼치지 않음  단점  디자인이 복잡해짐   참고  Head First Design Patterns SLiPP::위키 Bridge Pattern 예제 소스  </description>
      <content>&lt;h2 id=&#34;브릿지-패턴이란&#34;&gt;브릿지 패턴이란?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;구현부와 추상층을 분리한 패턴&lt;/p&gt;
&lt;p&gt;구현 뿐만 아니라 추상화 부분까지 변경시켜야 하는 경우에 사용하는 구조적 디자인 패턴.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/bridge/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Abstraction&lt;/code&gt;
추상화된 인터페이스&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RefinedAbstraction&lt;/code&gt;
정의된 인터페이스를 확장하는 객체&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Implementor&lt;/code&gt;
구현 클래스의 인터페이스를 정의&lt;br&gt;
&lt;code&gt;Abstraction&lt;/code&gt;의 인터페이스와 일치 할 필요는 없다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteImplementor&lt;/code&gt;
&lt;code&gt;Implementor&lt;/code&gt;의 인터페이스를 구현하고 구체적인 구현한 객체&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;구현을 인터페이스에 완전히 결합시키지 않음&lt;br&gt;
-&amp;gt; 구현과 추상화된 부분을 분리시킬 수 있음.&lt;/li&gt;
&lt;li&gt;추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있음&lt;/li&gt;
&lt;li&gt;추상화된 부분을 구현한 구상 클래스를 바꿔도 클라이언트에 영향을 끼치지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;디자인이 복잡해짐&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/display/SLS/Bridge+Pattern&#34;&gt;SLiPP::위키 Bridge Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/structural/BridgePattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>빌더 패턴</title>
      <link>/programming/design-pattern/%EB%B9%8C%EB%8D%94-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Thu, 24 Jun 2021 20:44:04 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EB%B9%8C%EB%8D%94-%ED%8C%A8%ED%84%B4/</guid>
      <description>구조  Builder
Prouduct 객체의 요소들을 생성하기 위한 추상 인터페이스를 정의 ConcreateBuilder
Builder에서 정의해둔 인터페이스를 구현 Director
Builder 인터페이스를 사용하는 객체를 합성 Product
빌더패턴을 이용하여 생성된 인스턴스  왜 사용해야 할까?  빌드 패턴은 객체를 생성하는 작업을 분할 하는 데 도움이 된다 ‎일반적으로 복잡한 만들기 논리를 캡슐화할 수 있다 여러 단계와 절차를 통해 객체가 생성된다.
각 단계 및 절차 별로 독립적인 추상화나 관리를 할 수 있음 물체는 준비가되기 전에 일부 지시된 단계에 의해 관리되어야하며 다른 클라이언트가 사용할 수 있다 ‎ 클라이언트 측에서는 추상 인터페이스만 바라보기에 구현 코드를 쉽게 바꿀 수 있다  이펙티브 자바 - 빌더 패턴 일반적으로 빌더 라고 하면 이쪽을 많이 부른다.</description>
      <content>&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/builder/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;Prouduct&lt;/code&gt; 객체의 요소들을 생성하기 위한 추상 인터페이스를 정의&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreateBuilder&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;Builder&lt;/code&gt;에서 정의해둔 인터페이스를 구현&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Director&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;Builder&lt;/code&gt; 인터페이스를 사용하는 객체를 합성&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Product&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;빌더패턴을 이용하여 생성된 인스턴스&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;왜-사용해야-할까&#34;&gt;왜 사용해야 할까?&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;빌드 패턴은 객체를 생성하는 작업을 분할 하는 데 도움이 된다&lt;/li&gt;
&lt;li&gt;‎일반적으로 복잡한 만들기 논리를 캡슐화할 수 있다&lt;/li&gt;
&lt;li&gt;여러 단계와 절차를 통해 객체가 생성된다.&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;각 단계 및 절차 별로 독립적인 추상화나 관리를 할 수 있음&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;물체는 준비가되기 전에 일부 지시된 단계에 의해 관리되어야하며 다른 클라이언트가 사용할 수 있다 ‎&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;클라이언트 측에서는 추상 인터페이스만 바라보기에 구현 코드를 쉽게 바꿀 수 있다&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;이펙티브-자바---빌더-패턴&#34;&gt;이펙티브 자바 - 빌더 패턴&lt;/h2&gt;
&lt;p&gt;일반적으로 &lt;code&gt;빌더&lt;/code&gt; 라고 하면 이쪽을 많이 부른다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;생성자에 매개변수가 많다면 빌더를 고려하라&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;객체 생성하는 몇가지 패턴이 존재하는데&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;점층적 생성자 패턴&lt;/li&gt;
&lt;li&gt;자바빈 패턴&lt;/li&gt;
&lt;li&gt;빌더 패턴&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;그 중 하나인 빌더 패턴이다&lt;/p&gt;
&lt;p&gt;해당 내용에 대한 글이 아니기에 언급만하고 생략&amp;hellip;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://johngrib.github.io/wiki/builder-pattern/#gof-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4%EC%9D%98-%EB%B9%8C%EB%8D%94-%ED%8C%A8%ED%84%B4&#34;&gt;빌더 패턴&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/creation/BuilderPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>책임 연쇄 패턴</title>
      <link>/programming/design-pattern/%EC%B1%85%EC%9E%84-%EC%97%B0%EC%87%84-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Thu, 24 Jun 2021 15:22:20 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%B1%85%EC%9E%84-%EC%97%B0%EC%87%84-%ED%8C%A8%ED%84%B4/</guid>
      <description>구조도   Handler 요청을 수신하고 처리객체들의 집합에 전달하는 인터페이스
집합의 첫 번째 핸들러에 대한 정보만 가지고 있음
  Concrete handlers 요청을 처리하는 객체
  Client 요청을 전달하는 클라이언트
  책임 연쇄 패턴이란? 명령 객체와 일련의 처리 객체를 포함하는 패턴으로
각각의 처리 객체는 명령 객체를 처리할 수 있는 연산의 집합이고
체인 안의 처리 객체가 핸들할 수 없는 명령은 다음 처리 객체로 넘겨지며 처리된다.
장점  요청을 보낸 쪽하고 받는 쪽을 분리시킬 수 있다 객체에는 사슬의 구조를 몰라도 되고 그 사슬에 들어있는</description>
      <content>&lt;h2 id=&#34;구조도&#34;&gt;구조도&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/chain-of-responsibility/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Handler&lt;/code&gt; 요청을 수신하고 처리객체들의 집합에 전달하는 인터페이스&lt;br&gt;
집합의 첫 번째 핸들러에 대한 정보만 가지고 있음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Concrete handlers&lt;/code&gt; 요청을 처리하는 객체&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Client&lt;/code&gt; 요청을 전달하는 클라이언트&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;책임-연쇄-패턴이란&#34;&gt;책임 연쇄 패턴이란?&lt;/h2&gt;
&lt;p&gt;명령 객체와 일련의 처리 객체를 포함하는 패턴으로&lt;/p&gt;
&lt;p&gt;각각의 처리 객체는 명령 객체를 처리할 수 있는 연산의 집합이고&lt;/p&gt;
&lt;p&gt;체인 안의 처리 객체가 핸들할 수 없는 명령은 다음 처리 객체로 넘겨지며 처리된다.&lt;/p&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;요청을 보낸 쪽하고 받는 쪽을 분리시킬 수 있다&lt;/li&gt;
&lt;li&gt;객체에는 사슬의 구조를 몰라도 되고 그 사슬에 들어있는&lt;br&gt;
다른 객체에 대한 직접적인 레퍼런스를 가질 필요도 없기 때문에&lt;br&gt;
객체를 단순하게 만들 수 있다&lt;/li&gt;
&lt;li&gt;사슬에 들어가는 객체를 바꾸거나 순서를 바꿈으로써 역활을 동적으로 추가/제거할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;실행시 과정을 살펴보거나 디버깅하기 힘들 수 있음&lt;/li&gt;
&lt;li&gt;요청이 반드시 처리된다는 보장이 없음&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참조&#34;&gt;참조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/behavioral/ChainOfResponsibility&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>어댑터 패턴</title>
      <link>/programming/design-pattern/%EC%96%B4%EB%8C%91%ED%84%B0-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Wed, 23 Jun 2021 23:10:43 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%96%B4%EB%8C%91%ED%84%B0-%ED%8C%A8%ED%84%B4/</guid>
      <description>구조도 Client 라이브러리나 외부 시스템을 사용하려는 요소
Adaptee 사용될 라이브러리나 외부 시스템
Target 어댑터가 구현하는 인터페이스
클라이언트는 인터페이스를 통해 어댑터와 연결된 Adaptee를 사용하게 된다.
Adapter Client 와 Adaptee 중간에서 호환성이 없는 둘을 연결하는 역활
어댑터 패턴이란? 한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환합니다.
어댑터를 이용하면 인터페이스 호환성 문제 때문에
같이 쓸 수 없는 클래스를 연결해서 쓸 수 있음.
왜 사용해야 할까? 인터페이스 호환 문제로 같이 쓸 수 없을 경우 사용한다곤 하는데</description>
      <content>&lt;h2 id=&#34;구조도&#34;&gt;구조도&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/adapter/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Client&lt;/code&gt; 라이브러리나 외부 시스템을 사용하려는 요소&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Adaptee&lt;/code&gt; 사용될 라이브러리나 외부 시스템&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Target&lt;/code&gt; 어댑터가 구현하는 인터페이스&lt;/p&gt;
&lt;p&gt;클라이언트는 인터페이스를 통해 어댑터와 연결된 &lt;code&gt;Adaptee&lt;/code&gt;를 사용하게 된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Adapter&lt;/code&gt; &lt;code&gt;Client&lt;/code&gt; 와 &lt;code&gt;Adaptee&lt;/code&gt; 중간에서 호환성이 없는 둘을 연결하는 역활&lt;/p&gt;
&lt;h2 id=&#34;어댑터-패턴이란&#34;&gt;어댑터 패턴이란?&lt;/h2&gt;
&lt;p&gt;한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환합니다.&lt;/p&gt;
&lt;p&gt;어댑터를 이용하면 인터페이스 호환성 문제 때문에&lt;/p&gt;
&lt;p&gt;같이 쓸 수 없는 클래스를 연결해서 쓸 수 있음.&lt;/p&gt;
&lt;h2 id=&#34;왜-사용해야-할까&#34;&gt;왜 사용해야 할까?&lt;/h2&gt;
&lt;p&gt;인터페이스 호환 문제로 같이 쓸 수 없을 경우 사용한다곤 하는데&lt;/p&gt;
&lt;p&gt;왜 써야할까?&lt;/p&gt;
&lt;p&gt;단순하게 사용할 수 있게 수정하면 되지 않을까?&lt;/p&gt;
&lt;h3 id=&#34;__어댑티-쪽을-수정한다고-가정하면__&#34;&gt;&lt;strong&gt;어댑티 쪽을 수정한다고 가정하면&amp;hellip;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;어댑티가 제공받은 라이브러리로써 직접적으로 수정이 불가능할 경우에 문제가 생길 수 있다.&lt;/p&gt;
&lt;p&gt;수정이 가능할 경우 이후 어댑티가 제공자에 의해 수정되는 경우&lt;/p&gt;
&lt;p&gt;해당 수정내용을 반영한 어댑티를 다시 수정해야 한다..&lt;/p&gt;
&lt;h3 id=&#34;__그렇다면-클라이언트-쪽은-어떨까__&#34;&gt;&lt;strong&gt;그렇다면 클라이언트 쪽은 어떨까&amp;hellip;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;클라이언트의 경우 단순한 구조라면 별 문제가 발생하지 않지만&lt;/p&gt;
&lt;p&gt;구조가 복잡해지거나 클라이언트의 연관관계가 많아질 경우&lt;/p&gt;
&lt;p&gt;클라이언트 수정시 다른 곳에서 문제가 발생할 수 있다&lt;/p&gt;
&lt;h3 id=&#34;요약하자면&#34;&gt;요약하자면&lt;/h3&gt;
&lt;p&gt;클라이언트와 어댑티를 수정하지 않고도 사용할 수 있게 해주는 패턴으로&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;수정시 발생할 수 있는 사이드 이펙트를 막게 해준다.&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참조&#34;&gt;참조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/structural/AdapterPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>추상 팩토리 패턴</title>
      <link>/programming/design-pattern/%EC%B6%94%EC%83%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Tue, 22 Jun 2021 16:16:12 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%B6%94%EC%83%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%8C%A8%ED%84%B4/</guid>
      <description>구조도 추상 팩토리 패턴이란? 상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나
독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공하기 위해 사용.
 AbstractFactory
개념적 제품에 대한 객체를 생성하는 연산으로 인터페이스를 정의한다. ConcreteFactory
구체적인 제품에 대한 객체를 생성하는 연산을 구현한다. AbstractProduct
개념적 제품 객체에 대한 인터페이스를 정의한다. ConcreteProduct
구체적으로 팩토리가 생성할 객체를 정의하고, AbstractProduct가 정의하는 인터페이스를 구현한다. Client
AbstractFactory와 AbstractProduct 클래스에 선언된 인터페이스를 사용한다.  언제 사용해야 할까?  객체 생성과 객체를 사용하는 시스템을 독립적으로 구성하기 위해서.</description>
      <content>&lt;h2 id=&#34;구조도&#34;&gt;구조도&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/abstractFactory/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;추상-팩토리-패턴이란&#34;&gt;추상 팩토리 패턴이란?&lt;/h2&gt;
&lt;p&gt;상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나&lt;/p&gt;
&lt;p&gt;독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공하기 위해 사용.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AbstractFactory&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;개념적 제품에 대한 객체를 생성하는 연산으로 인터페이스를 정의한다.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteFactory&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;구체적인 제품에 대한 객체를 생성하는 연산을 구현한다.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AbstractProduct&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;개념적 제품 객체에 대한 인터페이스를 정의한다.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteProduct&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;구체적으로 팩토리가 생성할 객체를 정의하고, &lt;code&gt;AbstractProduct&lt;/code&gt;가 정의하는 인터페이스를 구현한다.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Client&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;AbstractFactory&lt;/code&gt;와 &lt;code&gt;AbstractProduct&lt;/code&gt; 클래스에 선언된 인터페이스를 사용한다.&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;언제-사용해야-할까&#34;&gt;언제 사용해야 할까?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;객체 생성과 객체를 사용하는 시스템을 독립적으로 구성하기 위해서.&lt;/li&gt;
&lt;li&gt;여러 객체 군을 시스템이 사용하기 위해,
다른것으로도 대체를 쉽게 하기 위해서.&lt;/li&gt;
&lt;li&gt;여러 객체 군을 함께 사용할 수 있어야 할때.&lt;/li&gt;
&lt;li&gt;제품에 대한 클래스 라이브러리를 세부 정보를 노출없이 제공하고 싶을 때
&lt;ul&gt;
&lt;li&gt;클래스의 구현으로 제공이 아닌 인터페이스만 노출시키고 싶을 경우.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여러 팩토리에서 객체를 생산하며,&lt;/p&gt;
&lt;p&gt;생산된 객체가 무엇인지 몰라도 객체의 인터페이스만으로도 조작할 수 있음.&lt;/p&gt;
&lt;p&gt;객체를 조합으로 생성할 경우, 유용하게 사용할 수 있을듯하다.&lt;/p&gt;
&lt;p&gt;다만, 패턴 생성시 보일러 플레이트가 한두개가 아닌데.&lt;/p&gt;
&lt;p&gt;인터페이스 수정, 추상 메소드의 추가와 같은 수정사항이 생기는 경우&amp;hellip;&lt;/p&gt;
&lt;p&gt;고민을 좀 해봐야 할듯&amp;hellip;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참조&#34;&gt;참조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://johngrib.github.io/wiki/abstract-factory-pattern/&#34;&gt;기계인간 - Abstract Factory Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/creation/AbstractFactoryPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>디자인 패턴</title>
      <link>/programming/design-pattern/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 21 Jun 2021 17:12:33 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/</guid>
      <description>디자인패턴이란? 앞선 개발자들이 만들어 놓은 공통적으로 발생하는 문제에 대한 재사용 가능한 해결책 이다.
일반적으로 디자인 패턴 이라고 한다면 Gang-Of-Four 가 쓴 디자인패턴 서적의 내용이라고 보면 된다.
&amp;ldquo;디자인패턴이란? 일반적인 문제를 해결하기 위한 문제해결책이다.&amp;rdquo;
이정도까지만 알고 있어도 문제없을듯하다.
그래서 왜 디자인 패턴을 알아야 하나?   앞서 말한것과 같이 일반적으로 발생하는 문제 의 해결책으로 사용할 수 있기 때문에
  다른 개발자와 소통하기 편해진다.
  1번의 경우 앞에서 나온 내용이기에 생략한다.</description>
      <content>&lt;h1 id=&#34;디자인패턴이란&#34;&gt;디자인패턴이란?&lt;/h1&gt;
&lt;p&gt;앞선 개발자들이 만들어 놓은 &lt;strong&gt;공통적으로 발생하는 문제에 대한 재사용 가능한 해결책&lt;/strong&gt; 이다.&lt;/p&gt;
&lt;p&gt;일반적으로 &lt;strong&gt;디자인 패턴&lt;/strong&gt; 이라고 한다면 &lt;code&gt;Gang-Of-Four&lt;/code&gt; 가 쓴 디자인패턴 서적의 내용이라고 보면 된다.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;&lt;strong&gt;디자인패턴이란?  일반적인 문제를 해결하기 위한 문제해결책이다.&lt;/strong&gt;&amp;rdquo;&lt;/p&gt;
&lt;p&gt;이정도까지만 알고 있어도 문제없을듯하다.&lt;/p&gt;
&lt;h2 id=&#34;그래서-왜-디자인-패턴을-알아야-하나&#34;&gt;그래서 왜 디자인 패턴을 알아야 하나?&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;앞서 말한것과 같이 &lt;strong&gt;일반적으로 발생하는 문제&lt;/strong&gt; 의 해결책으로 사용할 수 있기 때문에&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다른 개발자와 소통하기 편해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1번의 경우 앞에서 나온 내용이기에 생략한다.&lt;/p&gt;
&lt;p&gt;2번의 경우, 다르게 생각하는 경우도 있겠지만&lt;/p&gt;
&lt;p&gt;디자인 패턴으로 소통을 한다면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;해당 패턴에 사용되는 장점, 단점 등 내포되는 내용을 포괄적으로 소통가능&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;장황하게 길어지는 설명을 단순한 단어로 처리할 수 있음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;좀 더 프로그램의 구조에 대해 살펴볼 수 있게 됨&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;등등&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이와 같은 장점들이 있다고 알려져 있다&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;좀-더-알아보자&#34;&gt;좀 더 알아보자&lt;/h2&gt;
&lt;p&gt;일반적으로 통용되는 디자인 패턴을 일컫는&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Gang-Of-Four&lt;/code&gt;의 디자인패턴에서는 여러가지 종류의 디자인 패턴을 소개하고 있다.&lt;/p&gt;
&lt;p&gt;각각의 패턴은 여러가지 종류로 그룹화할 수 있겠지만&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;        
        &lt;strong class=&#34;tx-royalblue&#34;&gt;생성 패턴(Creational Pattern)&lt;/strong&gt;&lt;/br&gt;
        &lt;sub class=&#34;tx-sub&#34;&gt;객체의 생성을 다루는 패턴&lt;/sub&gt;        
    &lt;/li&gt; 
    &lt;li&gt;
        &lt;strong class=&#34;tx-teal&#34;&gt;구조 패턴(Structural Pattern)&lt;/strong&gt;&lt;/br&gt;
        &lt;sub class=&#34;tx-sub&#34;&gt;객체의 구성을 다루는 패턴&lt;/sub&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;strong class=&#34;tx-orange&#34;&gt;행동 패턴(Behavioral Pattern)&lt;/strong&gt;&lt;/br&gt;
        &lt;sub class=&#34;tx-sub&#34;&gt;객체의 행동, 또는 객체 간의 상호작용을 다루는 패턴&lt;/sub&gt;
    &lt;/li&gt;
&lt;/ol&gt; 
일반적으로 사용되는 패턴들을 3가지로 구분하자면 다음과 같다
&lt;table style=&#34;text-align: center;&#34;&gt;
&lt;thead&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;strong class=&#34;tx-royalblue&#34;&gt;
                생성 패턴(Creational Pattern)
            &lt;/strong&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;strong class=&#34;tx-teal&#34;&gt;
            구조패턴(Structural Pattern)
            &lt;/strong&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;strong class=&#34;tx-orange&#34;&gt;
            행동 패턴(Behavioral Pattern)
            &lt;/strong&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
            &lt;span&gt;추상 팩토리 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Abstract Factory Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;어댑터 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Adapter Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;책임 연쇄 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Chain Of Responsibility&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
            &lt;span&gt;빌더 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Builder Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;브릿지 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Bridge Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;            
            &lt;span&gt;커맨드 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Command Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
            &lt;span&gt;팩토리 메소드 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Factory Method Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;컴포짓 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Composite Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;인터프리터 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Interpreter Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
            &lt;span&gt;프로토타입 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Prototype Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;데코레이터 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Decorator Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;이터레이터 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Iterator Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
            &lt;span&gt;싱글톤 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Singleton Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;퍼사드 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Facade Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;중재자 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Mediator Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;플라이웨이트 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Flyweight Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;메멘토 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Memento Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;프록시 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Proxy Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;옵저버 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Observer Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;상태 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;State Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;전략 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Strategy Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;방문자 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Visitor Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;템플릿 메소드 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Template Method Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;디자인 패턴이란 말그대로 패턴이기에 많은 패턴이 존재하기에&amp;hellip; 표기되지 않은 패턴이 있을 수 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참조&#34;&gt;참조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yes24.com/Product/Goods/17525598&#34;&gt;GoF의 디자인패턴&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;amp;ejkGb=KOR&amp;amp;barcode=9788979143409&#34;&gt;Head First Design Patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
  </channel>
</rss>

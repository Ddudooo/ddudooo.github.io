<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programmings on 공부한 내용 기록용</title>
    <link>/programming/</link>
    <description>Recent content in Programmings on 공부한 내용 기록용</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Mon, 05 Jul 2021 19:49:09 +0900</lastBuildDate><atom:link href="/programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>인터프리터 패턴</title>
      <link>/programming/design-pattern/%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 05 Jul 2021 19:49:09 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%ED%8C%A8%ED%84%B4/</guid>
      <description>인터프리터 패턴이란?  문법 규칙을 클래스화 한 구조로써, 일련의 규칙으로 정의된 언어를 해석하는 패턴
인터프리터 언어의 인터프리터와 같은 의미로 쓰임
 구조  Context
인터프리터가 구문해석을 실행하기 위한 정보를 제공. 문맥에 대한 정보를 모두 가지고 있음. AbstactExpression
공통 인터페이스 정의 TerminalExpression
해당 표현 이후에 그 이상 전개 되지 않는 표현. 코드상에서 해당 표현 이후에는 더 이상 다른 Expression 객체를 호출하지 않음. NonterminalExpression
이미 전개된 표현  장점  각 문법 규칙을 클래스로 표현하여 언어를 쉽게 구현 가능 언어의 변경이나 확장이 쉬운편 Visitor 패턴을 활용, 기존 Expression 구조의 변경 없이 새로운 종류의 해석을 정의할 수 있음  단점  문법 규칙의 갯수가 많아지면 시스템의 복잡도가 올라간다.</description>
      <content>&lt;h2 id=&#34;인터프리터-패턴이란&#34;&gt;인터프리터 패턴이란?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;문법 규칙을 클래스화 한 구조로써, 일련의 규칙으로 정의된 언어를 해석하는 패턴&lt;/p&gt;
&lt;p&gt;인터프리터 언어의 인터프리터와 같은 의미로 쓰임&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/interpreter/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Context&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;인터프리터가 구문해석을 실행하기 위한 정보를 제공. 문맥에 대한 정보를 모두 가지고 있음.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AbstactExpression&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;공통 인터페이스 정의&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TerminalExpression&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;해당 표현 이후에 그 이상 전개 되지 않는 표현.&lt;/br&gt; 코드상에서 해당 표현 이후에는 더 이상 다른 &lt;code&gt;Expression&lt;/code&gt; 객체를 호출하지 않음.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NonterminalExpression&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;이미 전개된 표현&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;각 문법 규칙을 클래스로 표현하여 언어를 쉽게 구현 가능&lt;/li&gt;
&lt;li&gt;언어의 변경이나 확장이 쉬운편&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Visitor&lt;/code&gt; 패턴을 활용, 기존 &lt;code&gt;Expression&lt;/code&gt; 구조의 변경 없이 새로운 종류의 해석을 정의할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;문법 규칙의 갯수가 많아지면 시스템의 복잡도가 올라간다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/display/SLS/Interpreter&#34;&gt;SLiPP::위키 Interpreter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.baeldung.com/java-interpreter-pattern&#34;&gt;Baeldung::Interpreter Design Pattern in Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/behavioral/InterpreterPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>컴포짓 패턴</title>
      <link>/programming/design-pattern/%EC%BB%B4%ED%8F%AC%EC%A7%93-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 05 Jul 2021 17:38:39 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%BB%B4%ED%8F%AC%EC%A7%93-%ED%8C%A8%ED%84%B4/</guid>
      <description>컴포짓 패턴이란?  개별 객체와 복합 객체를 동일하게 다룰 수 있도록 하는 패턴
여러 객체들로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루게 해주는 패턴
 구조  Component
모든 클래스에 해당하는 공통의 행동을 정의하고 구현. Composite
자식을 가지는 클래스를 구현함. 자식과 관련된 연산을 포함함. Leaf
구성 요소의 기본이 되는 객체를 정의함.  장점  단일 객체와 복합 객체를 구별하지 않고 동일하게 생각하여, 같은 객체군으로 묶어서 관리할 때 편리  단점  복합객체 내 구성 요소의 깊이 만큼, 코드 단위의 디버깅이 힘들어진다.</description>
      <content>&lt;h2 id=&#34;컴포짓-패턴이란&#34;&gt;컴포짓 패턴이란?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;개별 객체와 복합 객체를 동일하게 다룰 수 있도록 하는 패턴&lt;/p&gt;
&lt;p&gt;여러 객체들로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루게 해주는 패턴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/composite/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Component&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt; 모든 클래스에 해당하는 공통의 행동을 정의하고 구현.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Composite&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt; 자식을 가지는 클래스를 구현함. 자식과 관련된 연산을 포함함.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Leaf&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt; 구성 요소의 기본이 되는 객체를 정의함.&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;단일 객체와 복합 객체를 구별하지 않고 동일하게 생각하여, 같은 객체군으로 묶어서 관리할 때 편리&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;복합객체 내 구성 요소의 깊이 만큼, 코드 단위의 디버깅이 힘들어진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mygumi.tistory.com/343&#34;&gt;마이구미의 Hello World :: 컴포지트 패턴&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/structural/CompositePattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>JVM</title>
      <link>/programming/java/jvm/</link>
      <pubDate>Tue, 29 Jun 2021 18:15:41 +0900</pubDate>
      
      <guid>/programming/java/jvm/</guid>
      <description>Java Virtual Machine, JVM 이란?  자바 응용 프로그램을 실행시키기 위한 가상 머신으로 자바를 실행시키기 위한 프로그램
 일반적으로 다른 프로그래밍 언어의 경우,
컴파일러를 통해 컴파일할 때, 특정 시스템에 종속적인 결과물이 나오게 되어 있다
반면, Java 컴파일러는 JVM, Java Virtual Machine 에 대한 결과물을 생성한다.
이를 통해, 다른 플랫폼이나 환경이 다를 지라도 JVM만 있다면 동일한 결과물을 얻을 수 있게 되었다.
좀 더 자세히 살펴보자면
Java 컴파일러는 .java 파일을 .class 파일로 컴파일을 하게 되는데</description>
      <content>&lt;h1 id=&#34;java-virtual-machine-jvm-이란&#34;&gt;&lt;code&gt;Java Virtual Machine&lt;/code&gt;, &lt;code&gt;JVM&lt;/code&gt; 이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;자바 응용 프로그램을 실행시키기 위한 가상 머신으로 자바를 실행시키기 위한 프로그램&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;일반적으로 다른 프로그래밍 언어의 경우,&lt;/p&gt;
&lt;p&gt;컴파일러를 통해 컴파일할 때, 특정 시스템에 종속적인 결과물이 나오게 되어 있다&lt;/p&gt;
&lt;p&gt;반면, &lt;code&gt;Java&lt;/code&gt; 컴파일러는 &lt;code&gt;JVM&lt;/code&gt;, &lt;code&gt;Java Virtual Machine&lt;/code&gt; 에 대한 결과물을 생성한다.&lt;/p&gt;
&lt;p&gt;이를 통해, 다른 플랫폼이나 환경이 다를 지라도 &lt;code&gt;JVM&lt;/code&gt;만 있다면 동일한 결과물을 얻을 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;좀 더 자세히 살펴보자면&lt;/p&gt;
&lt;p&gt;Java 컴파일러는 &lt;code&gt;.java&lt;/code&gt; 파일을 &lt;code&gt;.class&lt;/code&gt; 파일로 컴파일을 하게 되는데&lt;/p&gt;
&lt;p&gt;이 &lt;code&gt;.class&lt;/code&gt; 파일이 &lt;code&gt;JVM&lt;/code&gt;에 입력되어 로드되고 실행되게 된다.&lt;/p&gt;
&lt;h2 id=&#34;jvm의-구조&#34;&gt;JVM의 구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/java/jvm/JVM-Architecture.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;위 구조도를 참고하여 보자면&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JVM&lt;/code&gt;은 크게 세가지 영역으로 이루어져 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;클래스 로더&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;ClassLoader Subsystem&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;런타임 데이터 영역&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Runtime Data Area&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;실행 엔진&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Execution Engine&lt;/sub&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;각각 영역에 대한 자세한 내용은 차차 다루도록 하고&lt;/p&gt;
&lt;p&gt;무슨 역할을 하는지 간략하게 알아보자&lt;/p&gt;
&lt;h3 id=&#34;클래스-로더&#34;&gt;클래스 로더&lt;/h3&gt;
&lt;p&gt;자바의 경우 동적으로 클래스를 읽어온다.
&lt;/br&gt;&lt;strong&gt;&lt;sub class=&#34;tx-sub tx-orange&#34;&gt;Dynamic Class Loading 동적 클래스 로딩&lt;/sub&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;런타임 상에 모든 코드가 JVM 상에 링크된다는 것인데, 좀 더 풀어서 설명하자면&lt;/p&gt;
&lt;p&gt;앞서 설명처럼&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;자바 프로그램이 실행될 때, 컴파일된 &lt;code&gt;class&lt;/code&gt; 파일로 입력되고 실행&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;해당 역할을 담당하는 시스템 모듈이다.&lt;/p&gt;
&lt;h3 id=&#34;런타임-데이터-영역&#34;&gt;런타임 데이터 영역&lt;/h3&gt;
&lt;p&gt;흔히 말하길 &lt;code&gt;메모리 영역&lt;/code&gt;이라고도 불리는 영역이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JVM 상에서 사용되는 데이터들을 적재하는 영역&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;메소드, 힙, 스택, PC Register, 네이티브 메소드 스택(&lt;code&gt;JNI&lt;/code&gt;) 등이 있다.&lt;/p&gt;
&lt;h3 id=&#34;실행-엔진&#34;&gt;실행 엔진&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;런타임 데이터 영역에 할당된 바이트코드를 실행시킨다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;실행 엔진은 바이트 코드를 읽어 명령어 단위로 실행시킨다.&lt;/p&gt;
&lt;p&gt;명령어 실행은 두 방식으로 나뉘어 실행되는데&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;인터프리터&lt;/li&gt;
&lt;li&gt;JIT 컴파일러&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 두가지 방식으로 실행된다.&lt;/p&gt;
&lt;p&gt;추가적으로 실행엔진에서 &lt;code&gt;GC&lt;/code&gt;라고 흔히 부르는&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Garbage Collector&lt;/code&gt;가 동작하여 불필요한 리소스를 반환한다.&lt;/p&gt;
&lt;h2 id=&#34;jre-jdk&#34;&gt;JRE? JDK?&lt;/h2&gt;
&lt;p&gt;JVM 구현체를 포함한 녀석들이다.&lt;/p&gt;
&lt;p&gt;흔히 말하는 &lt;code&gt;자바 다운로드&lt;/code&gt;, &lt;code&gt;자바 개발 환경 설정&lt;/code&gt;을 할때, 나오는 녀석들&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JRE
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;J&lt;/code&gt;ava &lt;code&gt;R&lt;/code&gt;untime &lt;code&gt;E&lt;/code&gt;nvironment 자바 실행 환경의 약자&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM&lt;/code&gt; + &lt;code&gt;Library&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;실행 관련 핵심 부분을 포함하고 있다&lt;/li&gt;
&lt;li&gt;개발 관련 도구 ❌&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JDK
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;J&lt;/code&gt;ava &lt;code&gt;D&lt;/code&gt;evelopment &lt;code&gt;K&lt;/code&gt;it 자바 개발도구의 약자&lt;/li&gt;
&lt;li&gt;JRE + 개발 관련 도구&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;자바-코드-실행-흐름&#34;&gt;자바 코드 실행 흐름&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;프로그램 실행&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM&lt;/code&gt;이 &lt;code&gt;OS&lt;/code&gt;로부터 메모리 할당&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;이 때 JVM이 할당 받은 메모리를 여러 영역으로 나누어 관리&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;자바 컴파일러가 &lt;code&gt;class&lt;/code&gt; 파일로 컴파일&lt;/li&gt;
&lt;li&gt;&lt;code&gt;클래스 로더&lt;/code&gt;를 통해 &lt;code&gt;JVM&lt;/code&gt;으로 로딩&lt;/li&gt;
&lt;li&gt;로딩된 &lt;code&gt;class&lt;/code&gt; 파일은 &lt;code&gt;실행 엔진&lt;/code&gt;을 통해 해석 및 실행&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dzone.com/articles/jvm-architecture-explained&#34;&gt;JVM architecture-explained&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wikidocs.net/257&#34;&gt;JVM, JRE, JDK의 차이&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/pages/viewpage.action?pageId=8880250&#34;&gt;SLiPP::위키 1장 - Java Virtual Machine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Java_virtual_machine&#34;&gt;wikipedia - Java_virtual_machine&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>팩토리 메소드 패턴</title>
      <link>/programming/design-pattern/%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%86%8C%EB%93%9C-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Tue, 29 Jun 2021 17:26:46 +0900</pubDate>
      
      <guid>/programming/design-pattern/%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%86%8C%EB%93%9C-%ED%8C%A8%ED%84%B4/</guid>
      <description>팩토리 메소드 패턴이란?  객체 생성을 캡슐화하는 패턴
자식(하위) 클래스가 어떤 객체를 생성할지를 결정하도록 하는 패턴
 구조 장점  객체의 자료형이 하위 클래스 의해서 결정되어 비교적 확장에 용이함 하위 클래스에서 객체를 생성할 때, 상위 클래스에서 그 객체에 대한 정확한 타입을 몰라도 됨 동일한 형태로 프로그래밍 가능함 확장성 있는 전체 프로젝트 구성 가능함 구상 클래스에 의존하지 않고 추상화된 것에 의존  단점  객체가 늘어날 때마다 하위 클래스 재정의로 인한 불필요한 많은 클래스 생성 가능성이 있음   참고  Head First Design Patterns SLiPP::위키 Factory Method Pattern 예제 소스  </description>
      <content>&lt;h2 id=&#34;팩토리-메소드-패턴이란&#34;&gt;팩토리 메소드 패턴이란?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;객체 생성을 캡슐화하는 패턴&lt;/p&gt;
&lt;p&gt;자식(하위) 클래스가 어떤 객체를 생성할지를 결정하도록 하는 패턴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/factoryMethod/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;객체의 자료형이 하위 클래스 의해서 결정되어 비교적 확장에 용이함&lt;/li&gt;
&lt;li&gt;하위 클래스에서 객체를 생성할 때, 상위 클래스에서 그 객체에 대한 정확한 타입을 몰라도 됨&lt;/li&gt;
&lt;li&gt;동일한 형태로 프로그래밍 가능함&lt;/li&gt;
&lt;li&gt;확장성 있는 전체 프로젝트 구성 가능함&lt;/li&gt;
&lt;li&gt;구상 클래스에 의존하지 않고 추상화된 것에 의존&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;객체가 늘어날 때마다 하위 클래스 재정의로 인한 불필요한 많은 클래스 생성 가능성이 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/display/SLS/Factory+Method+Pattern&#34;&gt;SLiPP::위키 Factory Method Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/creation/FactoryMethodPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>커맨드 패턴</title>
      <link>/programming/design-pattern/%EC%BB%A4%EB%A7%A8%EB%93%9C-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 28 Jun 2021 15:55:24 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%BB%A4%EB%A7%A8%EB%93%9C-%ED%8C%A8%ED%84%B4/</guid>
      <description>커맨드 패턴이란?  요청을 객체의 형태로 캡슐화하여 사용자가 보낸 요청을 나중에 이용할 수 있도록
매서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴
 HEAD FIRST DESIGN 에서&amp;hellip;  커맨드 객체는 일련의 행동을 특정 리시버하고 연결시킴으로써 요구 사항을 캡슐화한 것이라는 점을 이미 배웠습니다.
이렇게 하기 위해서 행동과 리시버를 한 객체에 집어넣고, execute()라는 메소드 하나만 외부에 공개하는 방법을 씁니다.
이 메소드 호출에 의해서 리시버에서 일련의 작업이 처리됩니다.</description>
      <content>&lt;h2 id=&#34;커맨드-패턴이란&#34;&gt;커맨드 패턴이란?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;요청을 객체의 형태로 캡슐화하여 사용자가 보낸 요청을 나중에 이용할 수 있도록&lt;/p&gt;
&lt;p&gt;매서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;head-first-design-에서&#34;&gt;HEAD FIRST DESIGN 에서&amp;hellip;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;커맨드 객체는 일련의 행동을 특정 리시버하고 연결시킴으로써 요구 사항을 캡슐화한 것이라는 점을 이미 배웠습니다.&lt;/p&gt;
&lt;p&gt;이렇게 하기 위해서 행동과 리시버를 한 객체에 집어넣고, execute()라는 메소드 하나만 외부에 공개하는 방법을 씁니다.&lt;/p&gt;
&lt;p&gt;이 메소드 호출에 의해서 리시버에서 일련의 작업이 처리됩니다.&lt;/p&gt;
&lt;p&gt;외부에서 볼 때는 어떤 객체가 리시버 역할을 하는지, 그 리시버에서 실제로 어떤 일을 하는지 알 수 없습니다.&lt;/p&gt;
&lt;p&gt;그냥 execute() 메소드를 호출하면 요구 사항이 처리된다는 것만 알 수 있을 뿐이죠.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/command/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Command&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;실행될 기능에 대한 인터페이스&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteCommand&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;실제로 실행되는 기능을 구현&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Invoker&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;기능의 실행을 요청하는 호출자 클래스&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;ConcreteCommand&lt;/code&gt;에서 &lt;code&gt;execute&lt;/code&gt; 메서드를 구현할 때 필요한 클래스&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;작업을 요청하는 클래스와 실제로 작업을 수행하는 클래스를 분리하여 시스템의 결합도를 낮출 수 있음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기존 코드를 수정하지 않고 새로운 기능을 비교적 쉽게 추가할 수 있음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동작자체를 객체화하여 일련의 트랜잭션을 객체단위로 제공할 수 있음&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;구현 및 유지보수해야 하는 클래스가 많아지게 됨.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://johngrib.github.io/wiki/command-pattern/&#34;&gt;기계인간 John Grib Command Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/behavioral/CommandPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>브릿지 패턴</title>
      <link>/programming/design-pattern/%EB%B8%8C%EB%A6%BF%EC%A7%80-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Fri, 25 Jun 2021 17:17:15 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EB%B8%8C%EB%A6%BF%EC%A7%80-%ED%8C%A8%ED%84%B4/</guid>
      <description>브릿지 패턴이란?  구현부와 추상층을 분리한 패턴
구현 뿐만 아니라 추상화 부분까지 변경시켜야 하는 경우에 사용하는 구조적 디자인 패턴.
 구조  Abstraction 추상화된 인터페이스 RefinedAbstraction 정의된 인터페이스를 확장하는 객체 Implementor 구현 클래스의 인터페이스를 정의
Abstraction의 인터페이스와 일치 할 필요는 없다. ConcreteImplementor Implementor의 인터페이스를 구현하고 구체적인 구현한 객체  장점  구현을 인터페이스에 완전히 결합시키지 않음
-&amp;gt; 구현과 추상화된 부분을 분리시킬 수 있음. 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있음 추상화된 부분을 구현한 구상 클래스를 바꿔도 클라이언트에 영향을 끼치지 않음  단점  디자인이 복잡해짐   참고  Head First Design Patterns SLiPP::위키 Bridge Pattern 예제 소스  </description>
      <content>&lt;h2 id=&#34;브릿지-패턴이란&#34;&gt;브릿지 패턴이란?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;구현부와 추상층을 분리한 패턴&lt;/p&gt;
&lt;p&gt;구현 뿐만 아니라 추상화 부분까지 변경시켜야 하는 경우에 사용하는 구조적 디자인 패턴.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/bridge/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Abstraction&lt;/code&gt;
추상화된 인터페이스&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RefinedAbstraction&lt;/code&gt;
정의된 인터페이스를 확장하는 객체&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Implementor&lt;/code&gt;
구현 클래스의 인터페이스를 정의&lt;br&gt;
&lt;code&gt;Abstraction&lt;/code&gt;의 인터페이스와 일치 할 필요는 없다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteImplementor&lt;/code&gt;
&lt;code&gt;Implementor&lt;/code&gt;의 인터페이스를 구현하고 구체적인 구현한 객체&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;구현을 인터페이스에 완전히 결합시키지 않음&lt;br&gt;
-&amp;gt; 구현과 추상화된 부분을 분리시킬 수 있음.&lt;/li&gt;
&lt;li&gt;추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있음&lt;/li&gt;
&lt;li&gt;추상화된 부분을 구현한 구상 클래스를 바꿔도 클라이언트에 영향을 끼치지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;디자인이 복잡해짐&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/display/SLS/Bridge+Pattern&#34;&gt;SLiPP::위키 Bridge Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/structural/BridgePattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>빌더 패턴</title>
      <link>/programming/design-pattern/%EB%B9%8C%EB%8D%94-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Thu, 24 Jun 2021 20:44:04 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EB%B9%8C%EB%8D%94-%ED%8C%A8%ED%84%B4/</guid>
      <description>구조  Builder
Prouduct 객체의 요소들을 생성하기 위한 추상 인터페이스를 정의 ConcreateBuilder
Builder에서 정의해둔 인터페이스를 구현 Director
Builder 인터페이스를 사용하는 객체를 합성 Product
빌더패턴을 이용하여 생성된 인스턴스  왜 사용해야 할까?  빌드 패턴은 객체를 생성하는 작업을 분할 하는 데 도움이 된다 ‎일반적으로 복잡한 만들기 논리를 캡슐화할 수 있다 여러 단계와 절차를 통해 객체가 생성된다.
각 단계 및 절차 별로 독립적인 추상화나 관리를 할 수 있음 물체는 준비가되기 전에 일부 지시된 단계에 의해 관리되어야하며 다른 클라이언트가 사용할 수 있다 ‎ 클라이언트 측에서는 추상 인터페이스만 바라보기에 구현 코드를 쉽게 바꿀 수 있다  이펙티브 자바 - 빌더 패턴 일반적으로 빌더 라고 하면 이쪽을 많이 부른다.</description>
      <content>&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/builder/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;Prouduct&lt;/code&gt; 객체의 요소들을 생성하기 위한 추상 인터페이스를 정의&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreateBuilder&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;Builder&lt;/code&gt;에서 정의해둔 인터페이스를 구현&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Director&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;Builder&lt;/code&gt; 인터페이스를 사용하는 객체를 합성&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Product&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;빌더패턴을 이용하여 생성된 인스턴스&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;왜-사용해야-할까&#34;&gt;왜 사용해야 할까?&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;빌드 패턴은 객체를 생성하는 작업을 분할 하는 데 도움이 된다&lt;/li&gt;
&lt;li&gt;‎일반적으로 복잡한 만들기 논리를 캡슐화할 수 있다&lt;/li&gt;
&lt;li&gt;여러 단계와 절차를 통해 객체가 생성된다.&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;각 단계 및 절차 별로 독립적인 추상화나 관리를 할 수 있음&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;물체는 준비가되기 전에 일부 지시된 단계에 의해 관리되어야하며 다른 클라이언트가 사용할 수 있다 ‎&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;클라이언트 측에서는 추상 인터페이스만 바라보기에 구현 코드를 쉽게 바꿀 수 있다&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;이펙티브-자바---빌더-패턴&#34;&gt;이펙티브 자바 - 빌더 패턴&lt;/h2&gt;
&lt;p&gt;일반적으로 &lt;code&gt;빌더&lt;/code&gt; 라고 하면 이쪽을 많이 부른다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;생성자에 매개변수가 많다면 빌더를 고려하라&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;객체 생성하는 몇가지 패턴이 존재하는데&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;점층적 생성자 패턴&lt;/li&gt;
&lt;li&gt;자바빈 패턴&lt;/li&gt;
&lt;li&gt;빌더 패턴&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;그 중 하나인 빌더 패턴이다&lt;/p&gt;
&lt;p&gt;해당 내용에 대한 글이 아니기에 언급만하고 생략&amp;hellip;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://johngrib.github.io/wiki/builder-pattern/#gof-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4%EC%9D%98-%EB%B9%8C%EB%8D%94-%ED%8C%A8%ED%84%B4&#34;&gt;빌더 패턴&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/creation/BuilderPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>책임 연쇄 패턴</title>
      <link>/programming/design-pattern/%EC%B1%85%EC%9E%84-%EC%97%B0%EC%87%84-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Thu, 24 Jun 2021 15:22:20 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%B1%85%EC%9E%84-%EC%97%B0%EC%87%84-%ED%8C%A8%ED%84%B4/</guid>
      <description>구조도   Handler 요청을 수신하고 처리객체들의 집합에 전달하는 인터페이스
집합의 첫 번째 핸들러에 대한 정보만 가지고 있음
  Concrete handlers 요청을 처리하는 객체
  Client 요청을 전달하는 클라이언트
  책임 연쇄 패턴이란? 명령 객체와 일련의 처리 객체를 포함하는 패턴으로
각각의 처리 객체는 명령 객체를 처리할 수 있는 연산의 집합이고
체인 안의 처리 객체가 핸들할 수 없는 명령은 다음 처리 객체로 넘겨지며 처리된다.
장점  요청을 보낸 쪽하고 받는 쪽을 분리시킬 수 있다 객체에는 사슬의 구조를 몰라도 되고 그 사슬에 들어있는</description>
      <content>&lt;h2 id=&#34;구조도&#34;&gt;구조도&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/chain-of-responsibility/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Handler&lt;/code&gt; 요청을 수신하고 처리객체들의 집합에 전달하는 인터페이스&lt;br&gt;
집합의 첫 번째 핸들러에 대한 정보만 가지고 있음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Concrete handlers&lt;/code&gt; 요청을 처리하는 객체&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Client&lt;/code&gt; 요청을 전달하는 클라이언트&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;책임-연쇄-패턴이란&#34;&gt;책임 연쇄 패턴이란?&lt;/h2&gt;
&lt;p&gt;명령 객체와 일련의 처리 객체를 포함하는 패턴으로&lt;/p&gt;
&lt;p&gt;각각의 처리 객체는 명령 객체를 처리할 수 있는 연산의 집합이고&lt;/p&gt;
&lt;p&gt;체인 안의 처리 객체가 핸들할 수 없는 명령은 다음 처리 객체로 넘겨지며 처리된다.&lt;/p&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;요청을 보낸 쪽하고 받는 쪽을 분리시킬 수 있다&lt;/li&gt;
&lt;li&gt;객체에는 사슬의 구조를 몰라도 되고 그 사슬에 들어있는&lt;br&gt;
다른 객체에 대한 직접적인 레퍼런스를 가질 필요도 없기 때문에&lt;br&gt;
객체를 단순하게 만들 수 있다&lt;/li&gt;
&lt;li&gt;사슬에 들어가는 객체를 바꾸거나 순서를 바꿈으로써 역활을 동적으로 추가/제거할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;실행시 과정을 살펴보거나 디버깅하기 힘들 수 있음&lt;/li&gt;
&lt;li&gt;요청이 반드시 처리된다는 보장이 없음&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참조&#34;&gt;참조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/behavioral/ChainOfResponsibility&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>어댑터 패턴</title>
      <link>/programming/design-pattern/%EC%96%B4%EB%8C%91%ED%84%B0-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Wed, 23 Jun 2021 23:10:43 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%96%B4%EB%8C%91%ED%84%B0-%ED%8C%A8%ED%84%B4/</guid>
      <description>구조도 Client 라이브러리나 외부 시스템을 사용하려는 요소
Adaptee 사용될 라이브러리나 외부 시스템
Target 어댑터가 구현하는 인터페이스
클라이언트는 인터페이스를 통해 어댑터와 연결된 Adaptee를 사용하게 된다.
Adapter Client 와 Adaptee 중간에서 호환성이 없는 둘을 연결하는 역활
어댑터 패턴이란? 한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환합니다.
어댑터를 이용하면 인터페이스 호환성 문제 때문에
같이 쓸 수 없는 클래스를 연결해서 쓸 수 있음.
왜 사용해야 할까? 인터페이스 호환 문제로 같이 쓸 수 없을 경우 사용한다곤 하는데</description>
      <content>&lt;h2 id=&#34;구조도&#34;&gt;구조도&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/adapter/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Client&lt;/code&gt; 라이브러리나 외부 시스템을 사용하려는 요소&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Adaptee&lt;/code&gt; 사용될 라이브러리나 외부 시스템&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Target&lt;/code&gt; 어댑터가 구현하는 인터페이스&lt;/p&gt;
&lt;p&gt;클라이언트는 인터페이스를 통해 어댑터와 연결된 &lt;code&gt;Adaptee&lt;/code&gt;를 사용하게 된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Adapter&lt;/code&gt; &lt;code&gt;Client&lt;/code&gt; 와 &lt;code&gt;Adaptee&lt;/code&gt; 중간에서 호환성이 없는 둘을 연결하는 역활&lt;/p&gt;
&lt;h2 id=&#34;어댑터-패턴이란&#34;&gt;어댑터 패턴이란?&lt;/h2&gt;
&lt;p&gt;한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환합니다.&lt;/p&gt;
&lt;p&gt;어댑터를 이용하면 인터페이스 호환성 문제 때문에&lt;/p&gt;
&lt;p&gt;같이 쓸 수 없는 클래스를 연결해서 쓸 수 있음.&lt;/p&gt;
&lt;h2 id=&#34;왜-사용해야-할까&#34;&gt;왜 사용해야 할까?&lt;/h2&gt;
&lt;p&gt;인터페이스 호환 문제로 같이 쓸 수 없을 경우 사용한다곤 하는데&lt;/p&gt;
&lt;p&gt;왜 써야할까?&lt;/p&gt;
&lt;p&gt;단순하게 사용할 수 있게 수정하면 되지 않을까?&lt;/p&gt;
&lt;h3 id=&#34;__어댑티-쪽을-수정한다고-가정하면__&#34;&gt;&lt;strong&gt;어댑티 쪽을 수정한다고 가정하면&amp;hellip;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;어댑티가 제공받은 라이브러리로써 직접적으로 수정이 불가능할 경우에 문제가 생길 수 있다.&lt;/p&gt;
&lt;p&gt;수정이 가능할 경우 이후 어댑티가 제공자에 의해 수정되는 경우&lt;/p&gt;
&lt;p&gt;해당 수정내용을 반영한 어댑티를 다시 수정해야 한다..&lt;/p&gt;
&lt;h3 id=&#34;__그렇다면-클라이언트-쪽은-어떨까__&#34;&gt;&lt;strong&gt;그렇다면 클라이언트 쪽은 어떨까&amp;hellip;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;클라이언트의 경우 단순한 구조라면 별 문제가 발생하지 않지만&lt;/p&gt;
&lt;p&gt;구조가 복잡해지거나 클라이언트의 연관관계가 많아질 경우&lt;/p&gt;
&lt;p&gt;클라이언트 수정시 다른 곳에서 문제가 발생할 수 있다&lt;/p&gt;
&lt;h3 id=&#34;요약하자면&#34;&gt;요약하자면&lt;/h3&gt;
&lt;p&gt;클라이언트와 어댑티를 수정하지 않고도 사용할 수 있게 해주는 패턴으로&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;수정시 발생할 수 있는 사이드 이펙트를 막게 해준다.&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참조&#34;&gt;참조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/structural/AdapterPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>추상 팩토리 패턴</title>
      <link>/programming/design-pattern/%EC%B6%94%EC%83%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Tue, 22 Jun 2021 16:16:12 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%B6%94%EC%83%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%8C%A8%ED%84%B4/</guid>
      <description>구조도 추상 팩토리 패턴이란? 상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나
독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공하기 위해 사용.
 AbstractFactory
개념적 제품에 대한 객체를 생성하는 연산으로 인터페이스를 정의한다. ConcreteFactory
구체적인 제품에 대한 객체를 생성하는 연산을 구현한다. AbstractProduct
개념적 제품 객체에 대한 인터페이스를 정의한다. ConcreteProduct
구체적으로 팩토리가 생성할 객체를 정의하고, AbstractProduct가 정의하는 인터페이스를 구현한다. Client
AbstractFactory와 AbstractProduct 클래스에 선언된 인터페이스를 사용한다.  언제 사용해야 할까?  객체 생성과 객체를 사용하는 시스템을 독립적으로 구성하기 위해서.</description>
      <content>&lt;h2 id=&#34;구조도&#34;&gt;구조도&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/abstractFactory/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;추상-팩토리-패턴이란&#34;&gt;추상 팩토리 패턴이란?&lt;/h2&gt;
&lt;p&gt;상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나&lt;/p&gt;
&lt;p&gt;독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공하기 위해 사용.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AbstractFactory&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;개념적 제품에 대한 객체를 생성하는 연산으로 인터페이스를 정의한다.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteFactory&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;구체적인 제품에 대한 객체를 생성하는 연산을 구현한다.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AbstractProduct&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;개념적 제품 객체에 대한 인터페이스를 정의한다.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteProduct&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;구체적으로 팩토리가 생성할 객체를 정의하고, &lt;code&gt;AbstractProduct&lt;/code&gt;가 정의하는 인터페이스를 구현한다.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Client&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;AbstractFactory&lt;/code&gt;와 &lt;code&gt;AbstractProduct&lt;/code&gt; 클래스에 선언된 인터페이스를 사용한다.&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;언제-사용해야-할까&#34;&gt;언제 사용해야 할까?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;객체 생성과 객체를 사용하는 시스템을 독립적으로 구성하기 위해서.&lt;/li&gt;
&lt;li&gt;여러 객체 군을 시스템이 사용하기 위해,
다른것으로도 대체를 쉽게 하기 위해서.&lt;/li&gt;
&lt;li&gt;여러 객체 군을 함께 사용할 수 있어야 할때.&lt;/li&gt;
&lt;li&gt;제품에 대한 클래스 라이브러리를 세부 정보를 노출없이 제공하고 싶을 때
&lt;ul&gt;
&lt;li&gt;클래스의 구현으로 제공이 아닌 인터페이스만 노출시키고 싶을 경우.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여러 팩토리에서 객체를 생산하며,&lt;/p&gt;
&lt;p&gt;생산된 객체가 무엇인지 몰라도 객체의 인터페이스만으로도 조작할 수 있음.&lt;/p&gt;
&lt;p&gt;객체를 조합으로 생성할 경우, 유용하게 사용할 수 있을듯하다.&lt;/p&gt;
&lt;p&gt;다만, 패턴 생성시 보일러 플레이트가 한두개가 아닌데.&lt;/p&gt;
&lt;p&gt;인터페이스 수정, 추상 메소드의 추가와 같은 수정사항이 생기는 경우&amp;hellip;&lt;/p&gt;
&lt;p&gt;고민을 좀 해봐야 할듯&amp;hellip;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참조&#34;&gt;참조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://johngrib.github.io/wiki/abstract-factory-pattern/&#34;&gt;기계인간 - Abstract Factory Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/creation/AbstractFactoryPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>디자인 패턴</title>
      <link>/programming/design-pattern/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 21 Jun 2021 17:12:33 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/</guid>
      <description>디자인패턴이란? 앞선 개발자들이 만들어 놓은 공통적으로 발생하는 문제에 대한 재사용 가능한 해결책 이다.
일반적으로 디자인 패턴 이라고 한다면 Gang-Of-Four 가 쓴 디자인패턴 서적의 내용이라고 보면 된다.
&amp;ldquo;디자인패턴이란? 일반적인 문제를 해결하기 위한 문제해결책이다.&amp;rdquo;
이정도까지만 알고 있어도 문제없을듯하다.
그래서 왜 디자인 패턴을 알아야 하나?   앞서 말한것과 같이 일반적으로 발생하는 문제 의 해결책으로 사용할 수 있기 때문에
  다른 개발자와 소통하기 편해진다.
  1번의 경우 앞에서 나온 내용이기에 생략한다.</description>
      <content>&lt;h1 id=&#34;디자인패턴이란&#34;&gt;디자인패턴이란?&lt;/h1&gt;
&lt;p&gt;앞선 개발자들이 만들어 놓은 &lt;strong&gt;공통적으로 발생하는 문제에 대한 재사용 가능한 해결책&lt;/strong&gt; 이다.&lt;/p&gt;
&lt;p&gt;일반적으로 &lt;strong&gt;디자인 패턴&lt;/strong&gt; 이라고 한다면 &lt;code&gt;Gang-Of-Four&lt;/code&gt; 가 쓴 디자인패턴 서적의 내용이라고 보면 된다.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;&lt;strong&gt;디자인패턴이란?  일반적인 문제를 해결하기 위한 문제해결책이다.&lt;/strong&gt;&amp;rdquo;&lt;/p&gt;
&lt;p&gt;이정도까지만 알고 있어도 문제없을듯하다.&lt;/p&gt;
&lt;h2 id=&#34;그래서-왜-디자인-패턴을-알아야-하나&#34;&gt;그래서 왜 디자인 패턴을 알아야 하나?&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;앞서 말한것과 같이 &lt;strong&gt;일반적으로 발생하는 문제&lt;/strong&gt; 의 해결책으로 사용할 수 있기 때문에&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다른 개발자와 소통하기 편해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1번의 경우 앞에서 나온 내용이기에 생략한다.&lt;/p&gt;
&lt;p&gt;2번의 경우, 다르게 생각하는 경우도 있겠지만&lt;/p&gt;
&lt;p&gt;디자인 패턴으로 소통을 한다면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;해당 패턴에 사용되는 장점, 단점 등 내포되는 내용을 포괄적으로 소통가능&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;장황하게 길어지는 설명을 단순한 단어로 처리할 수 있음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;좀 더 프로그램의 구조에 대해 살펴볼 수 있게 됨&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;등등&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이와 같은 장점들이 있다고 알려져 있다&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;좀-더-알아보자&#34;&gt;좀 더 알아보자&lt;/h2&gt;
&lt;p&gt;일반적으로 통용되는 디자인 패턴을 일컫는&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Gang-Of-Four&lt;/code&gt;의 디자인패턴에서는 여러가지 종류의 디자인 패턴을 소개하고 있다.&lt;/p&gt;
&lt;p&gt;각각의 패턴은 여러가지 종류로 그룹화할 수 있겠지만&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;        
        &lt;strong class=&#34;tx-royalblue&#34;&gt;생성 패턴(Creational Pattern)&lt;/strong&gt;&lt;/br&gt;
        &lt;sub class=&#34;tx-sub&#34;&gt;객체의 생성을 다루는 패턴&lt;/sub&gt;        
    &lt;/li&gt; 
    &lt;li&gt;
        &lt;strong class=&#34;tx-teal&#34;&gt;구조 패턴(Structural Pattern)&lt;/strong&gt;&lt;/br&gt;
        &lt;sub class=&#34;tx-sub&#34;&gt;객체의 구성을 다루는 패턴&lt;/sub&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;strong class=&#34;tx-orange&#34;&gt;행동 패턴(Behavioral Pattern)&lt;/strong&gt;&lt;/br&gt;
        &lt;sub class=&#34;tx-sub&#34;&gt;객체의 행동, 또는 객체 간의 상호작용을 다루는 패턴&lt;/sub&gt;
    &lt;/li&gt;
&lt;/ol&gt; 
일반적으로 사용되는 패턴들을 3가지로 구분하자면 다음과 같다
&lt;table style=&#34;text-align: center;&#34;&gt;
&lt;thead&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;strong class=&#34;tx-royalblue&#34;&gt;
                생성 패턴(Creational Pattern)
            &lt;/strong&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;strong class=&#34;tx-teal&#34;&gt;
            구조패턴(Structural Pattern)
            &lt;/strong&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;strong class=&#34;tx-orange&#34;&gt;
            행동 패턴(Behavioral Pattern)
            &lt;/strong&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
            &lt;span&gt;추상 팩토리 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Abstract Factory Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;어댑터 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Adapter Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;책임 연쇄 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Chain Of Responsibility&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
            &lt;span&gt;빌더 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Builder Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;브릿지 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Bridge Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;            
            &lt;span&gt;커맨드 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Command Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
            &lt;span&gt;팩토리 메소드 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Factory Method Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;컴포짓 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Composite Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;인터프리터 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Interpreter Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
            &lt;span&gt;프로토타입 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Prototype Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;데코레이터 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Decorator Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;이터레이터 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Iterator Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
            &lt;span&gt;싱글톤 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Singleton Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;퍼사드 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Facade Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;중재자 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Mediator Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;플라이웨이트 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Flyweight Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;메멘토 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Memento Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;프록시 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Proxy Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;옵저버 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Observer Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;상태 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;State Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;전략 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Strategy Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;방문자 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Visitor Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;템플릿 메소드 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Template Method Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;디자인 패턴이란 말그대로 패턴이기에 많은 패턴이 존재하기에&amp;hellip; 표기되지 않은 패턴이 있을 수 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참조&#34;&gt;참조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yes24.com/Product/Goods/17525598&#34;&gt;GoF의 디자인패턴&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;amp;ejkGb=KOR&amp;amp;barcode=9788979143409&#34;&gt;Head First Design Patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
  </channel>
</rss>

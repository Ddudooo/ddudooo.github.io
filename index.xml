<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>공부한 내용 기록용</title>
    <link>/</link>
    <description>Recent content on 공부한 내용 기록용</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Mon, 19 Jul 2021 15:45:43 +0900</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>전략 패턴</title>
      <link>/programming/design-pattern/%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 19 Jul 2021 15:45:43 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4/</guid>
      <description>전략 패턴이란?  인터페이스와 위임을 사용하여 특정 기능을 자유롭게 변경할때 사용하는 패턴
행위를 캡슐화 하여 동적으로 바꿀 수 있게 해주는 패턴
 구조  Strategy
전략사용으로 해당 전략에 대한 인터페이스 제공 Context
인스턴스를 주입받아 사용하는 객체  장점 실제로 사용하는 객체의 수정없이
외부 코드의 변경이나 추가만으로 사용하는 객체의 행위를 변경할 수 있다
단점 추가하는 전략당 객체가 추가되어, 코드 자체가 늘어나 관리포인트가 늘어나게 된다.
 참고  tutorialspoint::Design Patterns - Strategy Pattern JayTech의 기술 블로그::[우아한테크코스] 4주차 후기 - 전략패턴의 적용 dltlsgh5.</description>
      <content>&lt;h1 id=&#34;전략-패턴이란&#34;&gt;전략 패턴이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;인터페이스와 위임을 사용하여 특정 기능을 자유롭게 변경할때 사용하는 패턴&lt;/p&gt;
&lt;p&gt;행위를 캡슐화 하여 동적으로 바꿀 수 있게 해주는 패턴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/strategy/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Strategy&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;전략사용으로 해당 전략에 대한 인터페이스 제공&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Context&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;인스턴스를 주입받아 사용하는 객체&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;p&gt;실제로 사용하는 객체의 수정없이&lt;br&gt;
외부 코드의 변경이나 추가만으로 사용하는 객체의 행위를 변경할 수 있다&lt;/p&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;p&gt;추가하는 전략당 객체가 추가되어, 코드 자체가 늘어나 관리포인트가 늘어나게 된다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/strategy_pattern.htm&#34;&gt;tutorialspoint::Design Patterns - Strategy Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pjh3749.tistory.com/249&#34;&gt;JayTech의 기술 블로그::[우아한테크코스] 4주차 후기 - 전략패턴의 적용&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://velog.io/@dltlsgh5/%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4strategy-pattern&#34;&gt;dltlsgh5.log::전략 패턴(strategy pattern)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>상태 패턴</title>
      <link>/programming/design-pattern/%EC%83%81%ED%83%9C-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 19 Jul 2021 14:03:58 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%83%81%ED%83%9C-%ED%8C%A8%ED%84%B4/</guid>
      <description>상태 패턴이란?  상태를 객체화 하여 상태가 행동을 할 수 있도록 위임하는 패턴
 구조  Context
객체의 상태를 정의하는 메소드의 인터페이스 State
상태에 따른 동작을 정의한 인터페이스 ConcreateState
State의 구현체  장점 객체 상태에 대한 내용이 한곳에 집중되어 유지 보수하기에 편한편이다
분기 처리시에 단순히 상태를 추가하고 그에 따른 내용만 추가하면 된다
단점 상태에 따른 클래스 수가 늘어남에 따라 유지보수가 오히려 힘들어질 수 있다
상태에 대한 내용이 적다면 오히려 불필요하게 코드만 복잡해질 수 있다</description>
      <content>&lt;h1 id=&#34;상태-패턴이란&#34;&gt;상태 패턴이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;상태를 객체화 하여 상태가 행동을 할 수 있도록 위임하는 패턴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/state/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Context&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;객체의 상태를 정의하는 메소드의 인터페이스&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;상태에 따른 동작을 정의한 인터페이스&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreateState&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;State의 구현체&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;p&gt;객체 상태에 대한 내용이 한곳에 집중되어 유지 보수하기에 편한편이다&lt;/p&gt;
&lt;p&gt;분기 처리시에 단순히 상태를 추가하고 그에 따른 내용만 추가하면 된다&lt;/p&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;p&gt;상태에 따른 클래스 수가 늘어남에 따라 유지보수가 오히려 힘들어질 수 있다&lt;/p&gt;
&lt;p&gt;상태에 대한 내용이 적다면 오히려 불필요하게 코드만 복잡해질 수 있다&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;참고&#34;&gt;참고&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/state_pattern.htm&#34;&gt;tutorialspoint::Design Patterns - State Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/display/SLS/State&#34;&gt;SLiPP::위키 - State&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://steady-coding.tistory.com/387&#34;&gt;느리더라도 꾸준하게::[디자인 패턴] 상태(State) 패턴이란?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>옵저버 패턴</title>
      <link>/programming/design-pattern/%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Sun, 18 Jul 2021 22:16:50 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4/</guid>
      <description>옵저버 패턴이란?  객체의 상태 변화를 관찰하는 관찰자들
즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다
메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴
주로 분산 이벤트 핸들링 시스템을 구현하는 데 사용 발행/구독 모델로 알려져 있기도 하다
 구조  Subject
Observer, 관찰자를 알고 있는 주체
관찰자를 등록하고 제거하는 인터페이스 제공 Observer Subject에서 변화에 대한 신호를 받아 들여 갱신하는 인터페이스 제공  장점 객체간의 결합을 느슨하게 유지할 수 있다 주체와 관찰자간 데이터 교환을 효과적으로 적용할 수 있다</description>
      <content>&lt;h1 id=&#34;옵저버-패턴이란&#34;&gt;옵저버 패턴이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;객체의 상태 변화를 관찰하는 관찰자들&lt;/p&gt;
&lt;p&gt;즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다&lt;br&gt;
메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴&lt;/p&gt;
&lt;p&gt;주로 분산 이벤트 핸들링 시스템을 구현하는 데 사용
발행/구독 모델로 알려져 있기도 하다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/observer/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Observer, 관찰자를 알고 있는 주체&lt;/sub&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;관찰자를 등록하고 제거하는 인터페이스 제공&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Observer&lt;/code&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Subject에서 변화에 대한 신호를 받아 들여 갱신하는 인터페이스 제공&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;p&gt;객체간의 결합을 느슨하게 유지할 수 있다
주체와 관찰자간 데이터 교환을 효과적으로 적용할 수 있다&lt;/p&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;p&gt;데이터 교환간에 오히려 결합도가 높아질 수 있다&lt;/p&gt;
&lt;p&gt;다수의 관찰자에게 데이터 교환시 오히려 상태관리가 힘들어지거나 시스템 전체에 영향을 끼칠 수 있다&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://coding-factory.tistory.com/710&#34;&gt;코딩팩토리::[Design Pattern] 옵저버 패턴(Observer Pattern)에 대하여&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://johngrib.github.io/wiki/observer-pattern/&#34;&gt;기계인간 John Grib::옵저버 패턴(Observer Pattern)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>프록시 패턴</title>
      <link>/programming/design-pattern/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Sat, 17 Jul 2021 17:22:02 +0900</pubDate>
      
      <guid>/programming/design-pattern/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/</guid>
      <description>프록시 패턴이란?  어떤 객체에 대한 접근을 제어하는 용도로 대리인이나 대변인에 해당하는 객체를 제공하는 패턴
다른 객에 대한 접근 제어나 가상 객체로 실제 처리시에만 처리 가능하게 하는 패턴
 구조  Subject
Proxy와 RealSubject의 인터페이스 Proxy
클라이언트 요구를 처리할 수 있을 만큼 처리, 자신만으로 처리가 안될시 실 객체에 위임 RealSubject
실제 처리하는 객체  종류  원격 프록시
원격 객체에 대한 접근 제어가 가능합니다 가상 프록시 Virtual Proxy
객체의 생성비용이 많이 들어 미리 생성하기 힘든 객체에 대한 접근 및 생성시점 등을 제어합니다 보호 프록시 Protection Proxy</description>
      <content>&lt;h1 id=&#34;프록시-패턴이란&#34;&gt;프록시 패턴이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;어떤 객체에 대한 접근을 제어하는 용도로 대리인이나 대변인에 해당하는 객체를 제공하는 패턴&lt;/p&gt;
&lt;p&gt;다른 객에 대한 접근 제어나 가상 객체로 실제 처리시에만 처리 가능하게 하는 패턴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/proxy/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Proxy와 RealSubject의 인터페이스&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Proxy&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;클라이언트 요구를 처리할 수 있을 만큼 처리, 자신만으로 처리가 안될시 실 객체에 위임&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RealSubject&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;실제 처리하는 객체&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;종류&#34;&gt;종류&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;원격 프록시&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;원격 객체에 대한 접근 제어가 가능합니다&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;가상 프록시&lt;/code&gt; &lt;code&gt;Virtual Proxy&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;객체의 생성비용이 많이 들어 미리 생성하기 힘든 객체에 대한 접근 및 생성시점 등을 제어합니다&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;보호 프록시&lt;/code&gt; &lt;code&gt;Protection Proxy&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;객체에 따른 접근 권한을 제어해야하는 객체에 대한 접근을 제어할 수 있습니다&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;방화벽 프록시&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;일련의 네트워크 자원에 대한 접근을 제어함으로써 주 객체를 &lt;span class=&#34;tx-orange&#34;&gt;&lt;strong&gt;나쁜&lt;/strong&gt;&lt;/span&gt; 클라이언트들로부터 보호하는 역할을 합니다&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;스마트 레퍼런스 프록시&lt;/code&gt; &lt;code&gt;Smart Reference Proxy&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;주 객체가 참조될 때마다 추가 행동을 제공합니다&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;캐싱 프록시&lt;/code&gt; &lt;code&gt;Caching Proxy&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;비용이 많이 드는 작업의 결과를 임시로 저장 하고&lt;/sub&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;추후 여러 클라이언트에 저장된 결과를 실제 작업처리 대신 보여주고 자원을 절약하는 역할을 합니다&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;동기화 프록시&lt;/code&gt; &lt;code&gt;Synchronization Proxy&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;여러 스레드에서 주 객체에 접근하는 경우에 안전하게 작업을 처리할 수 있게 해줍니다&lt;/sub&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;주로 분산 환경에서 일련의 객체에 대한 동기화 된 접근을 제어해주는 자바 스페이스에서 쓰입니다&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;복잡도 숨김 프록시&lt;/code&gt; &lt;code&gt;Complexity Hiding Proxy&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;복잡한 클래스들의 집합에 대한 접근을 제어하고, 복잡도를 숨깁니다&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;지연 복사 프록시&lt;/code&gt; &lt;code&gt;Copy-On-Write Proxy&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;클라이언트에서 필요로 할 때까지 객체가 복사되는 것을 지연시킴으로써 객체의 복사를 제어합니다&lt;/sub&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;span class=&#34;tx-orange&#34;&gt;&lt;strong&gt;변형된 가상 프록시&lt;/strong&gt;&lt;/span&gt;라고 할 수 있으며 Java 5 의 CopyOnWriteArrayList 에서 쓰입니다&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;p&gt;실제 처리되는 로직이 비용이 클 경우&lt;/p&gt;
&lt;p&gt;처리 순서를 미뤄 효율적으로 대처할 수 있다.&lt;/p&gt;
&lt;p&gt;실제 처리하는 객체에 대해 앞서 처리과정을 거친 후 처리할 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;p&gt;추가적으로 객체가 생성되어, 오히려 성능이 저하될 수 있다.&lt;/p&gt;
&lt;p&gt;올바른 처리과정을 위해 스레드 처리 및 동기화 로직을 적절히 구사해야한다.&lt;/p&gt;
&lt;p&gt;시스템 자체의 코드 복잡도가 늘어난다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Java언어로 배우는 디자인 패턴 입문&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/proxy_pattern.htm&#34;&gt;tutorialspoint&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/display/SLS/Proxy+Pattern&#34;&gt;SLiPP::위키 - Proxy Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jdm.kr/blog/235&#34;&gt;JDM&amp;rsquo;s Blog::프록시 패턴(Proxy Pattern)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developside.tistory.com/80&#34;&gt;소스코드 요리사::프록시 패턴(proxy pattern) 이란?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>메멘토 패턴</title>
      <link>/programming/design-pattern/%EB%A9%94%EB%A9%98%ED%86%A0-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Fri, 16 Jul 2021 19:57:12 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EB%A9%94%EB%A9%98%ED%86%A0-%ED%8C%A8%ED%84%B4/</guid>
      <description>메멘토 패턴이란?  객체를 이전 상태로 되돌릴 수 있는 기능을 제공하는 패턴
객체의 상태를 이전 상태로 복원하려는 위치를 줄이기 위해 사용
 구조  Originator
저장하려는 객체 Memento
Originator의 특정 시점을 저장하는 객체 Caretaker
Memento의 보관 및 관리  장점 지정된 객체의 상태를 별도의 객체에 보관하여,
지정 객체와 별도의 라이프 사이클을 지니게 되어 비교적 안전하다
복구 기능 구현이 쉬운편
단점 상태를 저장하고 복구하는 기능 자체는 비용이 많이 소요될 수 있음</description>
      <content>&lt;h1 id=&#34;메멘토-패턴이란&#34;&gt;메멘토 패턴이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;객체를 이전 상태로 되돌릴 수 있는 기능을 제공하는 패턴&lt;/p&gt;
&lt;p&gt;객체의 상태를 이전 상태로 복원하려는 위치를 줄이기 위해 사용&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/memento/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Originator&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;저장하려는 객체&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Memento&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Originator의 특정 시점을 저장하는 객체&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Caretaker&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Memento의 보관 및 관리&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;p&gt;지정된 객체의 상태를 별도의 객체에 보관하여,&lt;br&gt;
지정 객체와 별도의 라이프 사이클을 지니게 되어 비교적 안전하다&lt;/p&gt;
&lt;p&gt;복구 기능 구현이 쉬운편&lt;/p&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;p&gt;상태를 저장하고 복구하는 기능 자체는 비용이 많이 소요될 수 있음&lt;/p&gt;
&lt;p&gt;객체를 시점에 따라 스냅샷 형식으로 저장해두기에 시스템의 자원에 영향을 미침&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Java언어로 배우는 디자인 패턴 입문&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/memento_pattern.htm&#34;&gt;tutorialspoint::Design Patterns - Memento Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.baeldung.com/java-memento-design-pattern&#34;&gt;Baeldung::Memento Design Pattern in Java&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>플라이웨이트 패턴</title>
      <link>/programming/design-pattern/%ED%94%8C%EB%9D%BC%EC%9D%B4%EC%9B%A8%EC%9D%B4%ED%8A%B8-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Fri, 16 Jul 2021 17:22:37 +0900</pubDate>
      
      <guid>/programming/design-pattern/%ED%94%8C%EB%9D%BC%EC%9D%B4%EC%9B%A8%EC%9D%B4%ED%8A%B8-%ED%8C%A8%ED%84%B4/</guid>
      <description>플라이웨이트 패턴이란?  동일하거나 유사한 객체들 사이에 가능한 많은 데이터를 서로 공유하여 사용하도록 하여 메모리 사용량을 최소화하는 패턴
주로 중복 생성 가능성이 높은 자원이나 자원 생성 비용은 크나 사용 빈도가 낮은 경우 사용하는 패턴이다
 구조  Flyweight
공유 자원을 갖는 객체 ConcreateFlyweight
Flyweight 구현체로 공유 상태에 대한 저장 공간 관리 및 확보  UnsharedConcreateFlyweight
공유하지 않는 구현체   FlyweightFactory
Flyweight 객체 생성 및 관리  장점 어플리케이션에 공유 자원을 갖는 객체가 많다면 자원을 절약할 수 있다.</description>
      <content>&lt;h1 id=&#34;플라이웨이트-패턴이란&#34;&gt;플라이웨이트 패턴이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;동일하거나 유사한 객체들 사이에 가능한 많은 데이터를 서로 공유하여 사용하도록 하여 메모리 사용량을 최소화하는 패턴&lt;/p&gt;
&lt;p&gt;주로 중복 생성 가능성이 높은 자원이나 자원 생성 비용은 크나 사용 빈도가 낮은 경우 사용하는 패턴이다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/flyweight/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Flyweight&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;공유 자원을 갖는 객체&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreateFlyweight&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Flyweight 구현체로 공유 상태에 대한 저장 공간 관리 및 확보&lt;/sub&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;UnsharedConcreateFlyweight&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;공유하지 않는 구현체&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FlyweightFactory&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Flyweight 객체 생성 및 관리&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;p&gt;어플리케이션에 공유 자원을 갖는 객체가 많다면 자원을 절약할 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;p&gt;공유 자원 호출시 존재하는 데이터 검색과 같은 비용이 발생한다.&lt;/p&gt;
&lt;p&gt;객체를 공유자원으로 다시 나눠서 구현하기에 비교적 코드가 복잡해진다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Java 언어로 배우는 디자인 패턴 입문&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://readystory.tistory.com/137&#34;&gt;준비된 개발자::[구조 패턴] 플라이웨이트 패턴(Flyweight Pattern) 이해 및 예제&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/flyweight_pattern.htm&#34;&gt;tutorialspoint::Design Patterns - Flyweight Pattern&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>중재자 패턴</title>
      <link>/programming/design-pattern/%EC%A4%91%EC%9E%AC%EC%9E%90-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Thu, 15 Jul 2021 21:06:27 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%A4%91%EC%9E%AC%EC%9E%90-%ED%8C%A8%ED%84%B4/</guid>
      <description>중재자 패턴이란?  클래스간 복잡한 로직을 캡슐화 하여 하나의 클래스에 위임하여 처리하는 패턴
M:N의 관계에서 M:1의 관계로 복잡도를 떨어뜨려 유지 보수 및 재사용의 확장성에 유리한 패턴
 구조  Mediator
Colleague 역할과 통신하여 조정을 실행하는 API  ConcreteMediator
Mediator 구현체   Colleague
Mediator 역할과 통신을 실행할 API  ConcreateColleague
Colleague 구현체    언제 사용할까? 복잡하게 얽힌 객체와 객체간에 관계를 풀어 줄때 주로 사용하게 된다.
프로그램을 작성하다 보면 상호작용을 해야하는 경우 객체들 간의 결합도가 증가하고 유연성이 떨어지는 경우가 발생하게 된다.</description>
      <content>&lt;h1 id=&#34;중재자-패턴이란&#34;&gt;중재자 패턴이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;클래스간 복잡한 로직을 캡슐화 하여 하나의 클래스에 위임하여 처리하는 패턴&lt;/p&gt;
&lt;p&gt;M:N의 관계에서 M:1의 관계로 복잡도를 떨어뜨려 유지 보수 및 재사용의 확장성에 유리한 패턴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/mediator/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Mediator&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Colleague 역할과 통신하여 조정을 실행하는 API&lt;/sub&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ConcreteMediator&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Mediator 구현체&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Colleague&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Mediator 역할과 통신을 실행할 API&lt;/sub&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ConcreateColleague&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Colleague 구현체&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;언제-사용할까&#34;&gt;언제 사용할까?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;복잡하게 얽힌 객체와 객체간에 관계를 풀어 줄때 주로 사용하게 된다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;프로그램을 작성하다 보면 상호작용을 해야하는 경우 객체들 간의 결합도가 증가하고 유연성이 떨어지는 경우가 발생하게 된다.&lt;/p&gt;
&lt;p&gt;이런 경우에&lt;/p&gt;
&lt;p&gt;이제 특정 개체가 명령을 내릴 필요가 있으면 중재자 개체에게 전달하기만 하면 되고,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;중재자는 해당 명령을 자신이 알고 있는 개체들 중에 적절한 개체에게 전달만 하면 된다.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;p&gt;시스템에서 관련된 기능을 하는 객체의 연결관계를 파악하기 쉬워진다.&lt;/p&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;p&gt;특정 로직에 맞춰져 있기에 재사용하기 힘들다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/mediator_pattern.htm&#34;&gt;tutorialspoint::Design Patterns - Mediator Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/display/SLS/Mediator&#34;&gt;SLiPP::위키 - Mediator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>퍼사드 패턴</title>
      <link>/programming/design-pattern/%ED%8D%BC%EC%82%AC%EB%93%9C-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Thu, 15 Jul 2021 18:35:43 +0900</pubDate>
      
      <guid>/programming/design-pattern/%ED%8D%BC%EC%82%AC%EB%93%9C-%ED%8C%A8%ED%84%B4/</guid>
      <description>퍼사드 패턴이란?  서브시스템의 일련의 인터페이스에 대한 통합된 인터페이스를 제공하는 패턴
퍼사드에서 고수준 인터페이스를 정의하기 때문에 서브시스템을 더 쉽게 사용할 수 있습니다.
 구조 왜 사용할까?   복잡한 서브 시스템을 단순하게 표현
  사용하는 클라이언트 입장에서 서브 시스템을 모두 알 필요 없어짐
  장점  서브 시스템간의 결합도가 낮아짐 사용하는 클라이언트에서 간결하게 파악할 수 있음  단점   서브 시스템을 호출하는 클래스를 새롭게 생성해야함
  구조가 좀 더 복잡해지고 관리가 어려워질 수 있음</description>
      <content>&lt;h1 id=&#34;퍼사드-패턴이란&#34;&gt;퍼사드 패턴이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;서브시스템의 일련의 인터페이스에 대한 통합된 인터페이스를 제공하는 패턴&lt;/p&gt;
&lt;p&gt;퍼사드에서 고수준 인터페이스를 정의하기 때문에 서브시스템을 더 쉽게 사용할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;구조&#34;&gt;구조&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/facade/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;왜-사용할까&#34;&gt;왜 사용할까?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;복잡한 서브 시스템을 단순하게 표현&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용하는 클라이언트 입장에서 서브 시스템을 모두 알 필요 없어짐&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;서브 시스템간의 결합도가 낮아짐&lt;/li&gt;
&lt;li&gt;사용하는 클라이언트에서 간결하게 파악할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;서브 시스템을 호출하는 클래스를 새롭게 생성해야함&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;구조가 좀 더 복잡해지고 관리가 어려워질 수 있음&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;참조&#34;&gt;참조&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/display/SLS/Facade+Pattern&#34;&gt;SLiPP::위키&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/facade_pattern.htm&#34;&gt;tutorialspoint::Design Patterns - Facade Pattern&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>싱글톤 패턴</title>
      <link>/programming/design-pattern/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Thu, 15 Jul 2021 16:19:27 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4/</guid>
      <description>싱글톤 패턴이란?  객체가 여러번 호출되더라고 동일한 객체를 보장하는 패턴
 구조  Singleton
하나의 인스턴스만을 생성하는 책임이 있으며
getInstance 메서드를 통해 모든 클라이언트에게 동일한 인스턴스를 반환하는 작업을 수행한다.  장점   단일 객체를 사용하기에 메모리 낭비를 방지할 수 있다
  전역에서 하나의 객체를 사용하기에 데이터를 공유하기에 쉽다.
  문제점  멀티 쓰레드 상에서 안전하게 작성하기 힘들다 클래스 내부에서 객체를 생성하기에 테스트시 어렵다   참조  [Design Pattern] 싱글턴 패턴이란 tutorialspoint::Design Pattern - Singleton Pattern  </description>
      <content>&lt;h1 id=&#34;싱글톤-패턴이란&#34;&gt;싱글톤 패턴이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;객체가 여러번 호출되더라고 동일한 객체를 보장하는 패턴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/singleton/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Singleton&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;하나의 인스턴스만을 생성하는 책임이 있으며&lt;/sub&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;getInstance&lt;/code&gt; 메서드를 통해 모든 클라이언트에게 동일한 인스턴스를 반환하는 작업을 수행한다.&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;단일 객체를 사용하기에 메모리 낭비를 방지할 수 있다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;전역에서 하나의 객체를 사용하기에 데이터를 공유하기에 쉽다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;문제점&#34;&gt;문제점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;멀티 쓰레드 상에서 안전하게 작성하기 힘들다&lt;/li&gt;
&lt;li&gt;클래스 내부에서 객체를 생성하기에 테스트시 어렵다&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;참조&#34;&gt;참조&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gmlwjd9405.github.io/2018/07/06/singleton-pattern.html&#34;&gt;[Design Pattern] 싱글턴 패턴이란&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/singleton_pattern.htm&#34;&gt;tutorialspoint::Design Pattern - Singleton Pattern&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>이터레이터 패턴</title>
      <link>/programming/design-pattern/%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Wed, 14 Jul 2021 17:56:18 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/</guid>
      <description>이터레이터 패턴이란?  반복자를 사용하여 컨테이너를 가로지르며 컨테이너의 요소들에 접근하는 디자인 패턴으로
컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 수 있게 해주는 방법을 제공해 준다.
 구조  Aggreate
Iterator 객체를 생성하는 인터페이스 ConcreateAggreate
Iterator를 제공하는 인터페이스의 구현체 Iterator
원소를 순회 및 접근하는 인터페이스 ConcreateIterator
Iterator의 구현체  왜 사용할까? 이터레이터 패턴을 사용할 경우
아래와 같은 특성이 생기게 되는데
 집합체의 응집도가 높아진다 집합체 내부 구현을 숨길 수 있다.</description>
      <content>&lt;h1 id=&#34;이터레이터-패턴이란&#34;&gt;이터레이터 패턴이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;반복자를 사용하여 컨테이너를 가로지르며 컨테이너의 요소들에 접근하는 디자인 패턴으로&lt;/p&gt;
&lt;p&gt;컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 수 있게 해주는 방법을 제공해 준다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/iterator/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Aggreate&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Iterator 객체를 생성하는 인터페이스&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreateAggreate&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Iterator를 제공하는 인터페이스의 구현체&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;원소를 순회 및 접근하는 인터페이스&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreateIterator&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Iterator의 구현체&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;왜-사용할까&#34;&gt;왜 사용할까?&lt;/h2&gt;
&lt;p&gt;이터레이터 패턴을 사용할 경우&lt;/p&gt;
&lt;p&gt;아래와 같은 특성이 생기게 되는데&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;집합체의 응집도가 높아진다&lt;/li&gt;
&lt;li&gt;집합체 내부 구현을 숨길 수 있다.&lt;/li&gt;
&lt;li&gt;집합체 내부 정보를 알필요 없이, 집합체의 모든 항목에 접근할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이러한 특성으로 인해 아래와 같은 목적 등으로 사용한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;집합체의 내부 구현을 보여주지 않고 접근을 허용하고 싶을때.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;집약체에 다양한 탐색 방법이 필요한 경우.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서로 다른 집합 구조에 대해서도 동일한 방법으로 접근하고 싶을 경우.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/behavioral/IteratorPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/pages/viewpage.action?pageId=30772665&#34;&gt;SLiPP::위키 - Iterator pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/iterator_pattern.htm&#34;&gt;tutorialspoint Design Patterns - Iterator Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jusungpark.tistory.com/25&#34;&gt;정리정리정리 - 이터레이터 패턴 (iterator pattern)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>데코레이터 패턴</title>
      <link>/programming/design-pattern/%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Tue, 13 Jul 2021 18:12:12 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/</guid>
      <description>데코레이터 패턴이란?  객체의 결합을 통해, 기능을 동적으로 확장할 수 있게 해주는 패턴
서브 클래스의 생성 대신 데코레이터를 통해 클래스의 기능을 확장하여 제공
 구조  Component
클라이언트가 사용하는 객체
기본 기능과 추가기능의 집합체 Decorator
추가적으로 제공할 기능의 공통 인터페이스 ConcreateComponent
기본 기능을 구현할 객체 ConcreateDecorator
추가적으로 제공의 개별적인 기능의 구현체  언제 사용할까? 기능을 추가할 객체를 수정하지 않고 새로운 기능이나 책임을 추가할 때
조합으로 재활용하여 다른 곳에도 사용하고 싶을 때</description>
      <content>&lt;h1 id=&#34;데코레이터-패턴이란&#34;&gt;데코레이터 패턴이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;객체의 결합을 통해, 기능을 동적으로 확장할 수 있게 해주는 패턴&lt;/p&gt;
&lt;p&gt;서브 클래스의 생성 대신 데코레이터를 통해 클래스의 기능을 확장하여 제공&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/decorator/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Component&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;클라이언트가 사용하는 객체&lt;/sub&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;기본 기능과 추가기능의 집합체&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Decorator&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;추가적으로 제공할 기능의 공통 인터페이스&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreateComponent&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;기본 기능을 구현할 객체&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreateDecorator&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;추가적으로 제공의 개별적인 기능의 구현체&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;언제-사용할까&#34;&gt;언제 사용할까?&lt;/h2&gt;
&lt;p&gt;기능을 추가할 객체를 수정하지 않고 새로운 기능이나 책임을 추가할 때&lt;/p&gt;
&lt;p&gt;조합으로 재활용하여 다른 곳에도 사용하고 싶을 때&lt;/p&gt;
&lt;p&gt;서브 클래스를 만드는 것이 비효율적일 때&lt;/p&gt;
&lt;h2 id=&#34;추가적으로-고려할점&#34;&gt;추가적으로 고려할점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Component&lt;/code&gt;는 장식을 추가할 베이스가 되는 역할이므로 작고 가볍게 정의하도록 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가급적 인터페이스만을 정의한다.&lt;/li&gt;
&lt;li&gt;무언가 저장하는 변수는 정의하지 않는다.
&lt;sub class=&#34;tx-sub&#34;&gt;(상속받는 여러 Decorator도 같이 복잡하고 무거워진다).&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;저장할 것이 있다면 서브클래스에서 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;상속 구조를 통해 &lt;code&gt;Decorator&lt;/code&gt;와 &lt;code&gt;Component&lt;/code&gt;가 같은 인터페이스를 갖게 해야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;투과적 인터페이스: &lt;code&gt;Decorator&lt;/code&gt;로 계속해서 감싸도 &lt;code&gt;Component&lt;/code&gt;의 메소드는 계속 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드를 수정하지 않고도 준비된 &lt;code&gt;Decorator&lt;/code&gt;을 조합해 기능을 추가할 수 있도록 생각해서 구현한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;비슷한 성질의 작은 클래스가 많이 만들어질 수 있다는 단점을 고려한다.
구현하려는 내용이 객체의 겉을 변경하려는 것인지, 속을 변경하려는 것인지 생각해 보자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;속을 변경하려는 것이라면 &lt;code&gt;strategy-pattern&lt;/code&gt;을 선택하는 것이 더 적절할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데코레이터 패턴으로 구현한 다음, 사용이 까다롭게 느껴지거나 자주 쓰는 조합이 있다면 다음 패턴을 사용해 제공하는 것을 고려해 보자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;builder-pattern&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;factory-pattern&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static-factory-method-pattern&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Decorator&lt;/code&gt;가 다른 &lt;code&gt;Decorator&lt;/code&gt;에 대해 알아야 할 필요가 있다면, 데코레이터 패턴의 사용 의도와 어긋나는 작업일 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;재귀적으로 기능을 갖게 하는 방법 외에도, &lt;code&gt;Decorator&lt;/code&gt;를 추가할 때마다 얻은 아이템을 &lt;code&gt;List&lt;/code&gt;로 관리하는 방법도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;참조&#34;&gt;참조&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://johngrib.github.io/wiki/decorator-pattern&#34;&gt;기계인간 John Grib :: 데코레이터 패턴&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/decorator_pattern.htm&#34;&gt;Tutorialspoint :: Design Patterns - Decorator Pattern&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>프로토타입 패턴</title>
      <link>/programming/design-pattern/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 12 Jul 2021 18:36:41 +0900</pubDate>
      
      <guid>/programming/design-pattern/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%ED%8C%A8%ED%84%B4/</guid>
      <description>프로토 타입 패턴이란?  원형이 되는 인스턴스로 새로운 객체 종류를 명시하고
객체를 복사하여 새로운 객체를 생성하는 패턴
 구조도 Prototype - 복제 자체에 대한 인터페이스를 선언합니다.
ConcretePrototype - 복제 자체에 대한 작업을 구현합니다.
Client - 프로토타입을 복제하도록 요청하여 새 개체를 만듭니다.
왜 사용할까? 이점은? 객체 생성시에 비용이 크게 드는 경우.
객체의 각 부분을 조합해서 생성하는 형태에도 적용이 가능하기에 비교적 간단하게 객체를 생성할 수 있다.
유의사항 프로토타입 패턴을 구현시에 복사하는 연산, clone() 메소드에 대한 구현인데</description>
      <content>&lt;h1 id=&#34;프로토-타입-패턴이란&#34;&gt;프로토 타입 패턴이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;원형이 되는 인스턴스로 새로운 객체 종류를 명시하고&lt;/p&gt;
&lt;p&gt;객체를 복사하여 새로운 객체를 생성하는 패턴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조도&#34;&gt;구조도&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/prototype/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Prototype&lt;/code&gt; - 복제 자체에 대한 인터페이스를 선언합니다.&lt;br&gt;
&lt;code&gt;ConcretePrototype&lt;/code&gt; - 복제 자체에 대한 작업을 구현합니다.&lt;br&gt;
&lt;code&gt;Client&lt;/code&gt; - 프로토타입을 복제하도록 요청하여 새 개체를 만듭니다.&lt;/p&gt;
&lt;h2 id=&#34;왜-사용할까-이점은&#34;&gt;왜 사용할까? 이점은?&lt;/h2&gt;
&lt;p&gt;객체 생성시에 비용이 크게 드는 경우.&lt;/p&gt;
&lt;p&gt;객체의 각 부분을 조합해서 생성하는 형태에도 적용이 가능하기에 비교적 간단하게 객체를 생성할 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;유의사항&#34;&gt;유의사항&lt;/h2&gt;
&lt;p&gt;프로토타입 패턴을 구현시에 복사하는 연산, &lt;code&gt;clone()&lt;/code&gt; 메소드에 대한 구현인데&lt;/p&gt;
&lt;p&gt;얕은 복사와 깊은 복사에 대한 문제가 있다&lt;/p&gt;
&lt;p&gt;인스턴스 변수까지 복사하는지 변수를 공유하는지 대한 문제.&lt;/p&gt;
&lt;h3 id=&#34;얕은-복사-깊은-복사&#34;&gt;얕은 복사, 깊은 복사&lt;/h3&gt;
&lt;p&gt;얕은 복사[&lt;code&gt;Shallow Copy&lt;/code&gt;], 깊은 복사[&lt;code&gt;Deep Copy&lt;/code&gt;]에 대해 간단히 알아보자&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;얕은 복사의 경우&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체를 복사시에 해당 객체만 복사하여 새 객체를 생성한다.&lt;/li&gt;
&lt;li&gt;원본의 참조값만 복사하여.&lt;br&gt;
인스턴스의 변수는 원본, 복사본 모두 같은 값을 바라보게 된다.
&lt;ul&gt;
&lt;li&gt;바라보는 변수값이 변경되면 원본, 복사본 모두 변경된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;깊은 복사의 경우&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체를 복사 할 때, 해당 객체와 인스턴스 변수까지 복사하는 방식.&lt;/li&gt;
&lt;li&gt;참조는 공유하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;참고&#34;&gt;참고&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/pages/viewpage.action?pageId=30771915&#34;&gt;SLiPP::위키 Prototype Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.baeldung.com/java-pattern-prototype&#34;&gt;Baeldung::Prototype Pattern in Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/prototype_pattern.htm&#34;&gt;Tutorialspoint::Design Patterns - Prototype Pattern&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>JVM(4) - Execution Engine</title>
      <link>/programming/java/jvm4/</link>
      <pubDate>Sun, 11 Jul 2021 16:48:38 +0900</pubDate>
      
      <guid>/programming/java/jvm4/</guid>
      <description>실행 엔진이란?  클래스 로더를 통해 런타임 데이터 영역에 배치된 Class
즉, 바이트 코드를 명령어 단위로 읽어 실행한다.
바이트 코드를 기계어로 읽어 실행함.
 실행 엔진 구조  Interpreter  바이트 코드를 한 라인씩 읽어 해석후 실행하는 방식. 속도가 느리다는 단점이 있다.   JustInTme  주로 JIT 이라고 줄여서 불리며, 인터프리터의 단점을 보안해서 등장 인터프리터 방식에 비해 실행속도는 빨라졌지만, 어셈블러 코드로 변경하는데 비용이 발생함. 반복 수행이 발생하지 않으면 인터프리터 방식이 더 빠르기에, 인터프리터 방식으로 진행하다 일정 기준을 넘어서면 JIT 방식으로 실행한다.</description>
      <content>&lt;h1 id=&#34;실행-엔진이란&#34;&gt;실행 엔진이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;클래스 로더를 통해 런타임 데이터 영역에 배치된 &lt;code&gt;Class&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;즉, 바이트 코드를 명령어 단위로 읽어 실행한다.&lt;/p&gt;
&lt;p&gt;바이트 코드를 기계어로 읽어 실행함.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;실행-엔진-구조&#34;&gt;실행 엔진 구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/java/execution_engine/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Interpreter&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;바이트 코드를 한 라인씩 읽어 해석후 실행하는 방식.&lt;/li&gt;
&lt;li&gt;속도가 느리다는 단점이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JustInTme&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;주로 &lt;code&gt;JIT&lt;/code&gt; 이라고 줄여서 불리며, 인터프리터의 단점을 보안해서 등장&lt;/li&gt;
&lt;li&gt;인터프리터 방식에 비해 실행속도는 빨라졌지만, 어셈블러 코드로 변경하는데 비용이 발생함.&lt;/li&gt;
&lt;li&gt;반복 수행이 발생하지 않으면 인터프리터 방식이 더 빠르기에, 인터프리터 방식으로 진행하다 일정 기준을 넘어서면 &lt;code&gt;JIT&lt;/code&gt; 방식으로 실행한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GarbageCollector&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;더 이상 참조되지 않는 객체를 모아서 정리한다.&lt;/li&gt;
&lt;li&gt;조건에 맞는 &lt;code&gt;GC&lt;/code&gt; 방식을 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;참고&#34;&gt;참고&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/pages/viewpage.action?pageId=8880270&#34;&gt;SLiPP::위키 - 5장 - Execution Engine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/en/database/oracle/oracle-database/19/jjdev/Oracle-JVM-JIT.html#GUID-23D5BA60-A2B3-45F9-93DF-81A3D971CA50&#34;&gt;Oracle JVM Just-in-Time Compiler (JIT)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.javacodegeeks.com/2018/04/jvm-architecture-execution-engine-in-jvm.html&#34;&gt;JVM Architecture: Execution Engine in JVM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>JVM(3) - Runtime Data Area</title>
      <link>/programming/java/jvm3/</link>
      <pubDate>Wed, 07 Jul 2021 22:12:16 +0900</pubDate>
      
      <guid>/programming/java/jvm3/</guid>
      <description>런타임 데이터 영역이란?  OS에서 JVM에 할당해준 메모리 영역을 Runtime Data Area,
런타임 데이터 영역이라 한다.
 런타임 데이터 영역은 그림 같이
 스택 PC 힙 메소드 네이티브 메소드 스택  5가지 영역으로 나눌 수 있다.
스택 쓰레드마다 런타임 스택이 생성되며
자바에서 메서드를 호출할 때 메서드의 프레임이 저장되는 영역
그리고 그 프레임 안에는 지역변수, 인자값, 리턴값 등이 저장된다.
메서드 호출 하나 하나마다 새 프레임이 생성되어 스택에 쌓이고
메서드 호출이 정상적으로 종료되거나 예외가 발생시 프레임은 스택에서 빠져나와 소멸된다.</description>
      <content>&lt;h1 id=&#34;런타임-데이터-영역이란&#34;&gt;런타임 데이터 영역이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;OS에서 JVM에 할당해준 메모리 영역을 Runtime Data Area,&lt;/p&gt;
&lt;p&gt;런타임 데이터 영역이라 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;/images/java/dataarea/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;런타임 데이터 영역은 그림 같이&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;스택&lt;/li&gt;
&lt;li&gt;PC&lt;/li&gt;
&lt;li&gt;힙&lt;/li&gt;
&lt;li&gt;메소드&lt;/li&gt;
&lt;li&gt;네이티브 메소드 스택&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;5가지 영역으로 나눌 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;스택&#34;&gt;스택&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;쓰레드마다 런타임 스택이 생성되며&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;자바에서 메서드를 호출할 때 메서드의 프레임이 저장되는 영역&lt;/p&gt;
&lt;p&gt;그리고 그 프레임 안에는 지역변수, 인자값, 리턴값 등이 저장된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;메서드 호출 하나 하나마다 새 프레임이 생성되어 스택에 쌓이고&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;메서드 호출이 정상적으로 종료되거나 예외가 발생시 프레임은 스택에서 빠져나와 소멸된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;쓰레드가 종료시 쓰레드가 가지고 있는 스택도 제거된다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;스택에도 직접적으로 저장되는 값이 있고 힙영역에 저장되며 레퍼런스만 저장하는 값이 있는데&lt;/p&gt;
&lt;p&gt;기본 자료형, &lt;code&gt;Primitive Type&lt;/code&gt; 의 경우 스택 영역에 저장되고&lt;/p&gt;
&lt;p&gt;기본 자료형을 제외한 타입의 경우&lt;/p&gt;
&lt;p&gt;힙 영역에 저장되고 스택 영역의 레퍼런스값을 통해 연결된다.&lt;/p&gt;
&lt;h2 id=&#34;pc-resisters&#34;&gt;PC Resisters&lt;/h2&gt;
&lt;p&gt;쓰레드가 생성될 때마다 생성되어, 각 쓰레드마다 존재함.&lt;/p&gt;
&lt;p&gt;쓰레드가 생성될 때마다 그 쓰레드가 어떠한 명령을 실행하게 될지에 대한 부분을 기록하는 메모리 공간을 말한다.&lt;/p&gt;
&lt;p&gt;JVM은 &lt;code&gt;Stacks-Base&lt;/code&gt; 방식으로 작동한다.&lt;/p&gt;
&lt;p&gt;JVM은 CPU에 직접 명령을 수행하지 않고 &lt;code&gt;Stack&lt;/code&gt;에서 &lt;code&gt;Operand&lt;/code&gt;를 뽑아내 이를 별도의 메모리 공간에 저장하는 방식을 취하는데, 이러한 메모리 공간을 &lt;code&gt;PC Registers&lt;/code&gt;라고 한다.&lt;/p&gt;
&lt;p&gt;연산을 위해 필요한 피연산자를 임시로 저장하기 위한 용도로 사용한다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;힙&#34;&gt;힙&lt;/h2&gt;
&lt;p&gt;모든 스레드 간에 공유되는 영역이며&lt;/p&gt;
&lt;p&gt;런타임 중에 생성된 개체, 클래스의 메타 데이터, 배열 등이 포함됨.&lt;/p&gt;
&lt;p&gt;JVM이 종료되면 소멸되어 OS에 반환된다.&lt;/p&gt;
&lt;p&gt;실행시 특정 플래그를 사용하여 JVM의 힙 요구량을 제어할 수 있으며,&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GC&lt;/code&gt;, &lt;code&gt;Garbage Collector&lt;/code&gt; 에 의해 이 공간이 관리되고 필요없어진 리소스를 정리하여 공간을 정리한다.&lt;/p&gt;
&lt;h3 id=&#34;힙힙의-구조&#34;&gt;힙::힙의 구조&lt;/h3&gt;
&lt;img src=&#34;/images/java/dataarea/heap.png&#34; alt=&#34;stack.png&#34; height=&#34;200 em&#34;/&gt;
&lt;p&gt;위에 그림은 일반적으로 알려진 힙의 구조다.&lt;/p&gt;
&lt;p&gt;크게 &lt;code&gt;Young Generation&lt;/code&gt; 과 &lt;code&gt;Old Generation&lt;/code&gt; 영역으로 나뉘며&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Young Generation&lt;/code&gt;은&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Eden&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Survivor&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;영역으로 나뉘게 된다.&lt;/p&gt;
&lt;h4 id=&#34;힙eden&#34;&gt;힙::Eden&lt;/h4&gt;
&lt;p&gt;객체가 최초로 &lt;code&gt;Heap&lt;/code&gt; 영역에 할당되는 장소&lt;/p&gt;
&lt;p&gt;이 영역이 가득 찰시에&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;새로 할당할 객체의 참조여부를 확인&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Live Object&lt;/code&gt;, 즉 사용중인 객체를 &lt;code&gt;Suvivor&lt;/code&gt; 영역으로 넘김&lt;/li&gt;
&lt;li&gt;참조가 사라진 &lt;code&gt;Garbage Object&lt;/code&gt;의 경우 그대로 둠&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Eden&lt;/code&gt; 영역을 모두 청소&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;힙survivor&#34;&gt;힙::Survivor&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Survivor0&lt;/code&gt; 과 &lt;code&gt;Survivor1&lt;/code&gt; 로 구성되는 영역&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Eden&lt;/code&gt; 영역에 살아 남은 객체들이 잠시 머무르는 곳&lt;br&gt;
&lt;code&gt;Live Object&lt;/code&gt; 사용중인 객체들은 하나의 &lt;code&gt;Survivor&lt;/code&gt; 영역만 사용하게 되며&lt;br&gt;
이러한 전반적인 과정을 &lt;code&gt;Minor GC&lt;/code&gt;라고 한다.&lt;/p&gt;
&lt;h4 id=&#34;힙old-generation&#34;&gt;힙::Old Generation&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Old Generation&lt;/code&gt;은 새로 &lt;code&gt;Heap&lt;/code&gt;에 할당된 객체가 들어오는 것이 아닌, &lt;code&gt;Survivor&lt;/code&gt; 영역에서 살아남아 오랫동안 참조 되었고 앞으로도 사용될 확률이 높은 객체들을 저장하는 영역이다.&lt;/p&gt;
&lt;p&gt;이러한 &lt;code&gt;Promotion&lt;/code&gt; 과정 중 &lt;code&gt;Old Generation&lt;/code&gt;의 메모리가 충분하지 않으면 해당 영역에서 &lt;code&gt;GC&lt;/code&gt;가 발생하는데 이를 &lt;code&gt;Major GC&lt;/code&gt;라고 한다.&lt;/p&gt;
&lt;h4 id=&#34;힙permanent&#34;&gt;힙::Permanent&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Permanent&lt;/code&gt; 영역은 보통 &lt;code&gt;Class Meta&lt;/code&gt; 정보나 메소드의 메타 정보,&lt;br&gt;
&lt;code&gt;static&lt;/code&gt; 변수와 상수 정보들이 저장되는 공간으로 흔히 &lt;code&gt;메타데이터 저장 영역&lt;/code&gt;이라고 한다.&lt;/p&gt;
&lt;p&gt;이 영역은 &lt;code&gt;JAVA8&lt;/code&gt; 부터 &lt;code&gt;Native Memory&lt;/code&gt; 영역으로 이동하였다.&lt;/p&gt;
&lt;p&gt;기존의 &lt;code&gt;Permanent&lt;/code&gt; 영역 존재하는 &lt;code&gt;static object&lt;/code&gt;는 &lt;code&gt;Heap&lt;/code&gt; 영역으로 옮겨졌다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;메소드-영역&#34;&gt;메소드 영역&lt;/h2&gt;
&lt;p&gt;메서드 영역에서는 런타임 상수풀과 메서드 데이터 내용, 생성자 및 메서드의 코드 내용을 저장.&lt;/p&gt;
&lt;p&gt;즉, 코드 레벨에 클레스 수준의 정보를 저장한다.&lt;/p&gt;
&lt;p&gt;여기에 클래스 변수가 저장되며&lt;/p&gt;
&lt;p&gt;해당 클래스가 코드에서 맨 처음 사용될 때 메서드 영역에 로딩되며&lt;/p&gt;
&lt;p&gt;추가로 이때 클래스의 static 블록이 존재한다면 단 한번 실행된다.&lt;/p&gt;
&lt;p&gt;&lt;strong class=&#34;tx-orange&#34;&gt;전역 변수 및 &lt;code&gt;statc 변수&lt;/code&gt; 가 프로그램 종료시 까지 어디서든 사용 가능한 이유다. &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;메소드 영역에 저장되는 데이터는&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Type Information&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;타입 정보&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Runtime Constant Pool&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;런타임 상수 풀&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Field Information&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;필드 정보&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Method Information&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;메서드 정보&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Class Variable&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;클래스 변수&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;와 같으며 해당 내용에 대해 좀 더 알아보자면&lt;/p&gt;
&lt;h3 id=&#34;메소드-영역type-information&#34;&gt;메소드 영역::Type Information&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Type&lt;/code&gt;의 전체 이름&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Type&lt;/code&gt;의 직계 하위 클래스 전체 이름&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Type&lt;/code&gt; 클래스 / 인터페이스 여부&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Type&lt;/code&gt;의 접근 제어자&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;public&lt;/code&gt; / &lt;code&gt;abstract&lt;/code&gt; / &lt;code&gt;final&lt;/code&gt;&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;연관된 인터페이스 이름 리스트&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;메소드-영역runtime-constant-pool&#34;&gt;메소드 영역::Runtime Constant Pool&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;타입의 모든 상수 정보를 가지고 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Type&lt;/code&gt;, &lt;code&gt;Field&lt;/code&gt;, &lt;code&gt;Method&lt;/code&gt;의 모든 &lt;code&gt;Symbolic Reference&lt;/code&gt; 정보&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Constant Pool&lt;/code&gt;의 &lt;code&gt;Entry&lt;/code&gt;는 인덱스 번호를 통해 접근&lt;/li&gt;
&lt;li&gt;객체의 접근 등 모든 참조를 위한 핵심 요소&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;메소드-영역field-information&#34;&gt;메소드 영역::Field Information&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;필드 타입&lt;/li&gt;
&lt;li&gt;필드의 접근 제어자
&lt;code&gt;public&lt;/code&gt; / &lt;code&gt;private&lt;/code&gt; / &lt;code&gt;protected&lt;/code&gt; / &lt;code&gt;static&lt;/code&gt; / &lt;code&gt;final&lt;/code&gt; / &lt;code&gt;volatile&lt;/code&gt; / &lt;code&gt;transient&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;메소드-영역method-information&#34;&gt;메소드 영역::Method Information&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Constructor&lt;/code&gt;, 생성자를 포함한 모든 메소드&lt;/li&gt;
&lt;li&gt;메소드 이름&lt;/li&gt;
&lt;li&gt;메소드 반환 타입&lt;/li&gt;
&lt;li&gt;메소드 파라미터 수와 타입&lt;/li&gt;
&lt;li&gt;메소드의 접근 제어자&lt;/li&gt;
&lt;li&gt;메소드 구현 부분이 있을 경우&lt;/li&gt;
&lt;li&gt;&lt;strong class=&#34;tx-orange&#34;&gt;메소드의 바이트 코드&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;메소드의 스택 프레임의 &lt;code&gt;Operand Stack&lt;/code&gt; 및
&lt;code&gt;Local variable section&lt;/code&gt;의 크기&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Exception Table&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;메소드-영역class-variable&#34;&gt;메소드 영역::Class Variable&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Class&lt;/code&gt; 변수는 &lt;code&gt;static&lt;/code&gt; 키워드로 선언된 변수를 의미&lt;/li&gt;
&lt;li&gt;모든 인스턴스에 공유 되며 인스턴스가 없어도
직접 접근이 가능하다.&lt;/li&gt;
&lt;li&gt;변수는 인스턴스의 것이 아니라 클래스에 속하게 된다.&lt;/li&gt;
&lt;li&gt;클래스를 사용 하기 이전에 이 변수들은 미리 메모리를 할당 받은 상태가 된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;final class&lt;/code&gt; 변수는 상수로 치환 되어 &lt;code&gt;Runtime Constant Pool&lt;/code&gt;에 값을 복사한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt; 변수는 해당 영역에 저장되지만, 기본형이 아닌 &lt;code&gt;static&lt;/code&gt; 클래스형 변수는 레퍼런스 변수만 저장되고 실제 인스턴스는 &lt;code&gt;Heap&lt;/code&gt;에 저장되어 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;네이티브-메소드-스택&#34;&gt;네이티브 메소드 스택&lt;/h2&gt;
&lt;p&gt;자바 이외의 언어로 만들어진 코드들을 위한 스택 영역&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JNI&lt;/code&gt; (Java Native Interface)를 통해 호출되는 &lt;code&gt;C&lt;/code&gt; / &lt;code&gt;C++&lt;/code&gt; 등의 코드를 수행하기 위한 스택&lt;/p&gt;
&lt;p&gt;JVM 스택과 마찬가지로 스레드 단위의 자료구조로 이루어져 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JVM&lt;/code&gt; 내부에 영향을 주지 않기 위해 따로 메모리 공간을 활용한다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고-사이트&#34;&gt;참고 사이트&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5&#34;&gt;Oracle docs::JVM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://smjeon.dev/etc/jvm-rda/&#34;&gt;SMJ Blog::JVM의 Runtime Data Area&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sgcomputer.tistory.com/64&#34;&gt;컴퓨터 공부하는 블로그::자바(Java) 메모리 구조 / Runtime Data Area&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/java_virtual_machine/java_virtual_machine_runtime_data_areas.htm&#34;&gt;tutorialspoint::Java Virtual Machine - Runtime Data Areas&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>JVM(2) - ClassLoader</title>
      <link>/programming/java/jvm2/</link>
      <pubDate>Tue, 06 Jul 2021 22:05:34 +0900</pubDate>
      
      <guid>/programming/java/jvm2/</guid>
      <description>클래스 로더란?  컴파일된 바이트 코드, .class 파일 읽어
class 객체를 생성하여 메모리에 적재하는 역할을 담당하는 객체
 아래에서 소개하는 내용은 내장 클래스 로더 위주로 알아보았다.
클래스 로더 구조 클래스 로더는 계층 구조로 이뤄져 있으며, 기본적으로 세가지 클래스 로더가 제공된다.
 부트 스트랩 클래스 로더
Bootstrap ClassLoader
JAVA_HOME\lib에 있는 코어 자바 API를 제공
최상위 우선순위를 가진 클래스 로더 익스텐션 클래스로더
Extension ClassLoader
JAVA_HOME\lib\ext 폴더 또는 java.ext.dirs
시스템 변수에 해당하는 위치에 있는 클래스를 읽는다.</description>
      <content>&lt;h1 id=&#34;클래스-로더란&#34;&gt;클래스 로더란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;컴파일된 바이트 코드, &lt;code&gt;.class&lt;/code&gt; 파일 읽어&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class&lt;/code&gt; 객체를 생성하여 메모리에 적재하는 역할을 담당하는 객체&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;아래에서 소개하는 내용은 내장 클래스 로더 위주로 알아보았다.&lt;/p&gt;
&lt;h2 id=&#34;클래스-로더-구조&#34;&gt;클래스 로더 구조&lt;/h2&gt;
&lt;img src=&#34;/images/java/classloader/structure.png&#34; alt=&#34;structure.png&#34; width=&#34;200 em&#34;/&gt;
&lt;p&gt;클래스 로더는 계층 구조로 이뤄져 있으며,  기본적으로 세가지 클래스 로더가 제공된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;부트 스트랩 클래스 로더&lt;br&gt;
&lt;sub class=&#34;tx-sub tx-teal&#34;&gt;Bootstrap ClassLoader&lt;/sub&gt;&lt;br&gt;
&lt;code&gt;JAVA_HOME\lib&lt;/code&gt;에 있는 코어 자바 API를 제공&lt;br&gt;
최상위 우선순위를 가진 클래스 로더&lt;/li&gt;
&lt;li&gt;익스텐션 클래스로더&lt;br&gt;
&lt;sub class=&#34;tx-sub tx-orange&#34;&gt;Extension ClassLoader&lt;/sub&gt;&lt;br&gt;
&lt;code&gt;JAVA_HOME\lib\ext&lt;/code&gt; 폴더 또는 &lt;code&gt;java.ext.dirs&lt;/code&gt;&lt;br&gt;
시스템 변수에 해당하는 위치에 있는 클래스를 읽는다.&lt;/li&gt;
&lt;li&gt;애플리케이션 클래스로더&lt;br&gt;
&lt;sub class=&#34;tx-sub tx-gold&#34;&gt;Application ClassLoader&lt;/sub&gt;&lt;br&gt;
애플리케이션 클래스패스에서 클래스를 읽는다.&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;(애플리케이션 실행할 때 주는 &lt;code&gt;-classpath&lt;/code&gt; 옵션 또는 &lt;code&gt;java.class.path&lt;/code&gt; 환경 변수의 값에 해당하는 위치)&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아래는 서버 응용 프로그램의 클래스 로더 구조에 대한 예시이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/java/classloader/classLoaderStructure.png&#34; alt=&#34;classloader-structure.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;after-java-9&#34;&gt;After Java 9&lt;/h3&gt;
&lt;p&gt;Java 9 부터 모듈 시스템 도입에 맞춰 기본 클래스 로더의 이름과 구현 내용등이 바뀌었는데&lt;/p&gt;
&lt;p&gt;자세한 내용은 &lt;a href=&#34;https://homoefficio.github.io/2018/10/13/Java-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94-%ED%9B%91%EC%96%B4%EB%B3%B4%EA%B8%B0/&#34;&gt;링크&lt;/a&gt;를 확인하도록 하자&lt;br&gt;
&lt;sub class=&#34;tx-sub tx-lightgray&#34;&gt;클래스로더의 전반적인 설명과 원칙 그리고 자바 9 이후 변경점 등을 자세히 설명해주고 있다. &lt;/sub&gt;&lt;/p&gt;
&lt;h1 id=&#34;클래스-로더의-진행-순서&#34;&gt;클래스 로더의 진행 순서&lt;/h1&gt;
&lt;p&gt;자바 응용 프로그램의 실행시, 클래스 로더의 구성 요소별 작동 방식에 대해 알아보자&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/java/classloader/classloader.png&#34; alt=&#34;classloader.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;클래스 로더는 크게 &lt;code&gt;로딩&lt;/code&gt;, &lt;code&gt;링크&lt;/code&gt;, &lt;code&gt;초기화&lt;/code&gt; 순으로 진행된다.&lt;/p&gt;
&lt;h2 id=&#34;로딩&#34;&gt;로딩&lt;/h2&gt;
&lt;p&gt;클래스 로더가 &lt;code&gt;.class&lt;/code&gt; 파일을 읽고&lt;br&gt;
그 내용에 따라 적절한 바이너리 데이터를 만들고 &lt;code&gt;메소드&lt;/code&gt; 영역에 저장.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이때 메소드 영역에 저장하는 데이터
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Fully Qualified Class Name&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub tx-lightgray&#34;&gt;클래스가 속한 패키지 명을 모두 포함한 이름&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class&lt;/code&gt; | &lt;code&gt;interface&lt;/code&gt; | &lt;code&gt;enum&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;메소드와 변수&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;로딩이 끝나면 해당 클래스 타입의 &lt;code&gt;Class 객체&lt;/code&gt;를 생성하여 &lt;code&gt;힙&lt;/code&gt; 영역에 저장.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Bootstrap ClassLoader&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;자바 런타임 코어 클래스 로드&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Extension ClassLoader&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Bootstrap Class 부모로 설정, 필요시 부모로 작업 위임&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Application ClassLoader&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;지정된 클래스 패스에 위치한 클래스 로드, Application에 해당되는 클래스들.&lt;/sub&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;순으로 진행된다.&lt;/p&gt;
&lt;h3 id=&#34;classnotfoundexception-noclassdeffounderror&#34;&gt;ClassNotFoundException? NoClassDefFoundError?&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ClassNotFoundException&lt;/code&gt; 클래스 로더가 클래스 패스에서 해당 클래스를 찾을 수 없을 경우 발생하는 에러로&lt;/p&gt;
&lt;p&gt;클래스 로더는 기본적으로&lt;br&gt;
&lt;code&gt;Application&lt;/code&gt; -&amp;gt; &lt;code&gt;Extension&lt;/code&gt; -&amp;gt; &lt;code&gt;Bootstrap&lt;/code&gt; 
순으로 클래스를 찾게 되는데,&lt;/p&gt;
&lt;p&gt;모두 진행 후 찾을 수 없는 경우 예외가 발생하게 된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NoClassDefFoundError&lt;/code&gt; 
컴파일 타임에는 클래스가 존재하지만&lt;/p&gt;
&lt;p&gt;런타임 당시에 클래스의 변경으로 인해 클래스의 스태틱 초기화 등으로&lt;/p&gt;
&lt;p&gt;런타임 당시에 클래스를 찾을 수 없는 경우 예외를 발생하게 된다.&lt;/p&gt;
&lt;h2 id=&#34;링크&#34;&gt;링크&lt;/h2&gt;
&lt;p&gt;링크의 경우 &lt;code&gt;Verify&lt;/code&gt;, &lt;code&gt;Prepare&lt;/code&gt;, &lt;code&gt;Resolve&lt;/code&gt; 세단계로 나눠져 있으며, 아래와 같은 순서로 진행된다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Verify&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;검증, &lt;code&gt;.class&lt;/code&gt; 파일 형식이 유효한지 체크&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Prepare&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;클래스 변수 (static 변수) 와 기본값에 필요한 메모리를 준비하는 과정&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Resolve&lt;/code&gt; &lt;sub class=&#34;tx-royalblue&#34;&gt;(optional)&lt;/sub&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;심볼릭 메모리 레퍼런스를 메소드 영역에 있는 실제 레퍼런스로 교체&lt;br&gt;
이과정에서 진행 될 수 있고, 실제 메소드를 실행당시에 실행될 수도 있음.&lt;/sub&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;초기화&#34;&gt;초기화&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Static&lt;/code&gt; 변수의 값 할당, &lt;code&gt;static&lt;/code&gt; 블럭이 있을 경우 이때 실행된다.&lt;/p&gt;
&lt;h1 id=&#34;마치며&#34;&gt;마치며&lt;/h1&gt;
&lt;p&gt;클래스 로더는 &lt;code&gt;Java&lt;/code&gt; 프로그램을 실행하는 데 필수적이며&lt;/p&gt;
&lt;p&gt;내부적으로 사용되는 &lt;code&gt;Bootstrap&lt;/code&gt; 클래스 로더는&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;다른 클래스 로더의 부모, 최상위 루트 클래스 로더 역할이며 JDK 내부 클래스를 로드합니다&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Extension&lt;/code&gt;, &lt;code&gt;Application&lt;/code&gt; 클래스 로더는&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;각각 Java 확장 디렉토리와 클래스 경로에서 클래스를 로드합니다&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;참고&#34;&gt;참고&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.baeldung.com/java-classloaders&#34;&gt;Baeldung::java-classloader&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.inflearn.com/course/the-java-code-manipulation&#34;&gt;더 자바, 코드를 조작하는 다양한 방법&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://homoefficio.github.io/2018/10/13/Java-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94-%ED%9B%91%EC%96%B4%EB%B3%B4%EA%B8%B0/&#34;&gt;Java 클래스로더 훑어보기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>인터프리터 패턴</title>
      <link>/programming/design-pattern/%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 05 Jul 2021 19:49:09 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%ED%8C%A8%ED%84%B4/</guid>
      <description>인터프리터 패턴이란?  문법 규칙을 클래스화 한 구조로써, 일련의 규칙으로 정의된 언어를 해석하는 패턴
인터프리터 언어의 인터프리터와 같은 의미로 쓰임
 구조  Context
인터프리터가 구문해석을 실행하기 위한 정보를 제공. 문맥에 대한 정보를 모두 가지고 있음. AbstactExpression
공통 인터페이스 정의 TerminalExpression
해당 표현 이후에 그 이상 전개 되지 않는 표현. 코드상에서 해당 표현 이후에는 더 이상 다른 Expression 객체를 호출하지 않음. NonterminalExpression
이미 전개된 표현  장점  각 문법 규칙을 클래스로 표현하여 언어를 쉽게 구현 가능 언어의 변경이나 확장이 쉬운편 Visitor 패턴을 활용, 기존 Expression 구조의 변경 없이 새로운 종류의 해석을 정의할 수 있음  단점  문법 규칙의 갯수가 많아지면 시스템의 복잡도가 올라간다.</description>
      <content>&lt;h2 id=&#34;인터프리터-패턴이란&#34;&gt;인터프리터 패턴이란?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;문법 규칙을 클래스화 한 구조로써, 일련의 규칙으로 정의된 언어를 해석하는 패턴&lt;/p&gt;
&lt;p&gt;인터프리터 언어의 인터프리터와 같은 의미로 쓰임&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/interpreter/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Context&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;인터프리터가 구문해석을 실행하기 위한 정보를 제공. 문맥에 대한 정보를 모두 가지고 있음.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AbstactExpression&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;공통 인터페이스 정의&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TerminalExpression&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;해당 표현 이후에 그 이상 전개 되지 않는 표현.&lt;/br&gt; 코드상에서 해당 표현 이후에는 더 이상 다른 &lt;code&gt;Expression&lt;/code&gt; 객체를 호출하지 않음.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NonterminalExpression&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;이미 전개된 표현&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;각 문법 규칙을 클래스로 표현하여 언어를 쉽게 구현 가능&lt;/li&gt;
&lt;li&gt;언어의 변경이나 확장이 쉬운편&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Visitor&lt;/code&gt; 패턴을 활용, 기존 &lt;code&gt;Expression&lt;/code&gt; 구조의 변경 없이 새로운 종류의 해석을 정의할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;문법 규칙의 갯수가 많아지면 시스템의 복잡도가 올라간다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/display/SLS/Interpreter&#34;&gt;SLiPP::위키 Interpreter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.baeldung.com/java-interpreter-pattern&#34;&gt;Baeldung::Interpreter Design Pattern in Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/behavioral/InterpreterPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>컴포짓 패턴</title>
      <link>/programming/design-pattern/%EC%BB%B4%ED%8F%AC%EC%A7%93-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 05 Jul 2021 17:38:39 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%BB%B4%ED%8F%AC%EC%A7%93-%ED%8C%A8%ED%84%B4/</guid>
      <description>컴포짓 패턴이란?  개별 객체와 복합 객체를 동일하게 다룰 수 있도록 하는 패턴
여러 객체들로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루게 해주는 패턴
 구조  Component
모든 클래스에 해당하는 공통의 행동을 정의하고 구현. Composite
자식을 가지는 클래스를 구현함. 자식과 관련된 연산을 포함함. Leaf
구성 요소의 기본이 되는 객체를 정의함.  장점  단일 객체와 복합 객체를 구별하지 않고 동일하게 생각하여, 같은 객체군으로 묶어서 관리할 때 편리  단점  복합객체 내 구성 요소의 깊이 만큼, 코드 단위의 디버깅이 힘들어진다.</description>
      <content>&lt;h2 id=&#34;컴포짓-패턴이란&#34;&gt;컴포짓 패턴이란?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;개별 객체와 복합 객체를 동일하게 다룰 수 있도록 하는 패턴&lt;/p&gt;
&lt;p&gt;여러 객체들로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루게 해주는 패턴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/composite/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Component&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt; 모든 클래스에 해당하는 공통의 행동을 정의하고 구현.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Composite&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt; 자식을 가지는 클래스를 구현함. 자식과 관련된 연산을 포함함.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Leaf&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt; 구성 요소의 기본이 되는 객체를 정의함.&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;단일 객체와 복합 객체를 구별하지 않고 동일하게 생각하여, 같은 객체군으로 묶어서 관리할 때 편리&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;복합객체 내 구성 요소의 깊이 만큼, 코드 단위의 디버깅이 힘들어진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mygumi.tistory.com/343&#34;&gt;마이구미의 Hello World :: 컴포지트 패턴&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/structural/CompositePattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>JVM</title>
      <link>/programming/java/jvm/</link>
      <pubDate>Tue, 29 Jun 2021 18:15:41 +0900</pubDate>
      
      <guid>/programming/java/jvm/</guid>
      <description>Java Virtual Machine, JVM 이란?  자바 응용 프로그램을 실행시키기 위한 가상 머신으로 자바를 실행시키기 위한 프로그램
 일반적으로 다른 프로그래밍 언어의 경우,
컴파일러를 통해 컴파일할 때, 특정 시스템에 종속적인 결과물이 나오게 되어 있다
반면, Java 컴파일러는 JVM, Java Virtual Machine 에 대한 결과물을 생성한다.
이를 통해, 다른 플랫폼이나 환경이 다를 지라도 JVM만 있다면 동일한 결과물을 얻을 수 있게 되었다.
좀 더 자세히 살펴보자면
Java 컴파일러는 .java 파일을 .class 파일로 컴파일을 하게 되는데</description>
      <content>&lt;h1 id=&#34;java-virtual-machine-jvm-이란&#34;&gt;&lt;code&gt;Java Virtual Machine&lt;/code&gt;, &lt;code&gt;JVM&lt;/code&gt; 이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;자바 응용 프로그램을 실행시키기 위한 가상 머신으로 자바를 실행시키기 위한 프로그램&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;일반적으로 다른 프로그래밍 언어의 경우,&lt;/p&gt;
&lt;p&gt;컴파일러를 통해 컴파일할 때, 특정 시스템에 종속적인 결과물이 나오게 되어 있다&lt;/p&gt;
&lt;p&gt;반면, &lt;code&gt;Java&lt;/code&gt; 컴파일러는 &lt;code&gt;JVM&lt;/code&gt;, &lt;code&gt;Java Virtual Machine&lt;/code&gt; 에 대한 결과물을 생성한다.&lt;/p&gt;
&lt;p&gt;이를 통해, 다른 플랫폼이나 환경이 다를 지라도 &lt;code&gt;JVM&lt;/code&gt;만 있다면 동일한 결과물을 얻을 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;좀 더 자세히 살펴보자면&lt;/p&gt;
&lt;p&gt;Java 컴파일러는 &lt;code&gt;.java&lt;/code&gt; 파일을 &lt;code&gt;.class&lt;/code&gt; 파일로 컴파일을 하게 되는데&lt;/p&gt;
&lt;p&gt;이 &lt;code&gt;.class&lt;/code&gt; 파일이 &lt;code&gt;JVM&lt;/code&gt;에 입력되어 로드되고 실행되게 된다.&lt;/p&gt;
&lt;h2 id=&#34;jvm의-구조&#34;&gt;JVM의 구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/java/jvm/JVM-Architecture.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;위 구조도를 참고하여 보자면&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JVM&lt;/code&gt;은 크게 세가지 영역으로 이루어져 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;클래스 로더&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;ClassLoader Subsystem&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;런타임 데이터 영역&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Runtime Data Area&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;실행 엔진&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Execution Engine&lt;/sub&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;각각 영역에 대한 자세한 내용은 차차 다루도록 하고&lt;/p&gt;
&lt;p&gt;무슨 역할을 하는지 간략하게 알아보자&lt;/p&gt;
&lt;h3 id=&#34;클래스-로더&#34;&gt;클래스 로더&lt;/h3&gt;
&lt;p&gt;자바의 경우 동적으로 클래스를 읽어온다.
&lt;/br&gt;&lt;strong&gt;&lt;sub class=&#34;tx-sub tx-orange&#34;&gt;Dynamic Class Loading 동적 클래스 로딩&lt;/sub&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;런타임 상에 모든 코드가 JVM 상에 링크된다는 것인데, 좀 더 풀어서 설명하자면&lt;/p&gt;
&lt;p&gt;앞서 설명처럼&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;자바 프로그램이 실행될 때, 컴파일된 &lt;code&gt;class&lt;/code&gt; 파일로 입력되고 실행&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;해당 역할을 담당하는 시스템 모듈이다.&lt;/p&gt;
&lt;h3 id=&#34;런타임-데이터-영역&#34;&gt;런타임 데이터 영역&lt;/h3&gt;
&lt;p&gt;흔히 말하길 &lt;code&gt;메모리 영역&lt;/code&gt;이라고도 불리는 영역이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JVM 상에서 사용되는 데이터들을 적재하는 영역&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;메소드, 힙, 스택, PC Register, 네이티브 메소드 스택(&lt;code&gt;JNI&lt;/code&gt;) 등이 있다.&lt;/p&gt;
&lt;h3 id=&#34;실행-엔진&#34;&gt;실행 엔진&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;런타임 데이터 영역에 할당된 바이트코드를 실행시킨다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;실행 엔진은 바이트 코드를 읽어 명령어 단위로 실행시킨다.&lt;/p&gt;
&lt;p&gt;명령어 실행은 두 방식으로 나뉘어 실행되는데&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;인터프리터&lt;/li&gt;
&lt;li&gt;JIT 컴파일러&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 두가지 방식으로 실행된다.&lt;/p&gt;
&lt;p&gt;추가적으로 실행엔진에서 &lt;code&gt;GC&lt;/code&gt;라고 흔히 부르는&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Garbage Collector&lt;/code&gt;가 동작하여 불필요한 리소스를 반환한다.&lt;/p&gt;
&lt;h2 id=&#34;jre-jdk&#34;&gt;JRE? JDK?&lt;/h2&gt;
&lt;p&gt;JVM 구현체를 포함한 녀석들이다.&lt;/p&gt;
&lt;p&gt;흔히 말하는 &lt;code&gt;자바 다운로드&lt;/code&gt;, &lt;code&gt;자바 개발 환경 설정&lt;/code&gt;을 할때, 나오는 녀석들&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JRE
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;J&lt;/code&gt;ava &lt;code&gt;R&lt;/code&gt;untime &lt;code&gt;E&lt;/code&gt;nvironment 자바 실행 환경의 약자&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM&lt;/code&gt; + &lt;code&gt;Library&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;실행 관련 핵심 부분을 포함하고 있다&lt;/li&gt;
&lt;li&gt;개발 관련 도구 ❌&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JDK
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;J&lt;/code&gt;ava &lt;code&gt;D&lt;/code&gt;evelopment &lt;code&gt;K&lt;/code&gt;it 자바 개발도구의 약자&lt;/li&gt;
&lt;li&gt;JRE + 개발 관련 도구&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;자바-코드-실행-흐름&#34;&gt;자바 코드 실행 흐름&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;프로그램 실행&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JVM&lt;/code&gt;이 &lt;code&gt;OS&lt;/code&gt;로부터 메모리 할당&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;이 때 JVM이 할당 받은 메모리를 여러 영역으로 나누어 관리&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;자바 컴파일러가 &lt;code&gt;class&lt;/code&gt; 파일로 컴파일&lt;/li&gt;
&lt;li&gt;&lt;code&gt;클래스 로더&lt;/code&gt;를 통해 &lt;code&gt;JVM&lt;/code&gt;으로 로딩&lt;/li&gt;
&lt;li&gt;로딩된 &lt;code&gt;class&lt;/code&gt; 파일은 &lt;code&gt;실행 엔진&lt;/code&gt;을 통해 해석 및 실행&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dzone.com/articles/jvm-architecture-explained&#34;&gt;JVM architecture-explained&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wikidocs.net/257&#34;&gt;JVM, JRE, JDK의 차이&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/pages/viewpage.action?pageId=8880250&#34;&gt;SLiPP::위키 1장 - Java Virtual Machine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Java_virtual_machine&#34;&gt;wikipedia - Java_virtual_machine&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>팩토리 메소드 패턴</title>
      <link>/programming/design-pattern/%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%86%8C%EB%93%9C-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Tue, 29 Jun 2021 17:26:46 +0900</pubDate>
      
      <guid>/programming/design-pattern/%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%86%8C%EB%93%9C-%ED%8C%A8%ED%84%B4/</guid>
      <description>팩토리 메소드 패턴이란?  객체 생성을 캡슐화하는 패턴
자식(하위) 클래스가 어떤 객체를 생성할지를 결정하도록 하는 패턴
 구조 장점  객체의 자료형이 하위 클래스 의해서 결정되어 비교적 확장에 용이함 하위 클래스에서 객체를 생성할 때, 상위 클래스에서 그 객체에 대한 정확한 타입을 몰라도 됨 동일한 형태로 프로그래밍 가능함 확장성 있는 전체 프로젝트 구성 가능함 구상 클래스에 의존하지 않고 추상화된 것에 의존  단점  객체가 늘어날 때마다 하위 클래스 재정의로 인한 불필요한 많은 클래스 생성 가능성이 있음   참고  Head First Design Patterns SLiPP::위키 Factory Method Pattern 예제 소스  </description>
      <content>&lt;h2 id=&#34;팩토리-메소드-패턴이란&#34;&gt;팩토리 메소드 패턴이란?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;객체 생성을 캡슐화하는 패턴&lt;/p&gt;
&lt;p&gt;자식(하위) 클래스가 어떤 객체를 생성할지를 결정하도록 하는 패턴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/factoryMethod/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;객체의 자료형이 하위 클래스 의해서 결정되어 비교적 확장에 용이함&lt;/li&gt;
&lt;li&gt;하위 클래스에서 객체를 생성할 때, 상위 클래스에서 그 객체에 대한 정확한 타입을 몰라도 됨&lt;/li&gt;
&lt;li&gt;동일한 형태로 프로그래밍 가능함&lt;/li&gt;
&lt;li&gt;확장성 있는 전체 프로젝트 구성 가능함&lt;/li&gt;
&lt;li&gt;구상 클래스에 의존하지 않고 추상화된 것에 의존&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;객체가 늘어날 때마다 하위 클래스 재정의로 인한 불필요한 많은 클래스 생성 가능성이 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/display/SLS/Factory+Method+Pattern&#34;&gt;SLiPP::위키 Factory Method Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/creation/FactoryMethodPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>커맨드 패턴</title>
      <link>/programming/design-pattern/%EC%BB%A4%EB%A7%A8%EB%93%9C-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 28 Jun 2021 15:55:24 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%BB%A4%EB%A7%A8%EB%93%9C-%ED%8C%A8%ED%84%B4/</guid>
      <description>커맨드 패턴이란?  요청을 객체의 형태로 캡슐화하여 사용자가 보낸 요청을 나중에 이용할 수 있도록
매서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴
 HEAD FIRST DESIGN 에서&amp;hellip;  커맨드 객체는 일련의 행동을 특정 리시버하고 연결시킴으로써 요구 사항을 캡슐화한 것이라는 점을 이미 배웠습니다.
이렇게 하기 위해서 행동과 리시버를 한 객체에 집어넣고, execute()라는 메소드 하나만 외부에 공개하는 방법을 씁니다.
이 메소드 호출에 의해서 리시버에서 일련의 작업이 처리됩니다.</description>
      <content>&lt;h2 id=&#34;커맨드-패턴이란&#34;&gt;커맨드 패턴이란?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;요청을 객체의 형태로 캡슐화하여 사용자가 보낸 요청을 나중에 이용할 수 있도록&lt;/p&gt;
&lt;p&gt;매서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;head-first-design-에서&#34;&gt;HEAD FIRST DESIGN 에서&amp;hellip;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;커맨드 객체는 일련의 행동을 특정 리시버하고 연결시킴으로써 요구 사항을 캡슐화한 것이라는 점을 이미 배웠습니다.&lt;/p&gt;
&lt;p&gt;이렇게 하기 위해서 행동과 리시버를 한 객체에 집어넣고, execute()라는 메소드 하나만 외부에 공개하는 방법을 씁니다.&lt;/p&gt;
&lt;p&gt;이 메소드 호출에 의해서 리시버에서 일련의 작업이 처리됩니다.&lt;/p&gt;
&lt;p&gt;외부에서 볼 때는 어떤 객체가 리시버 역할을 하는지, 그 리시버에서 실제로 어떤 일을 하는지 알 수 없습니다.&lt;/p&gt;
&lt;p&gt;그냥 execute() 메소드를 호출하면 요구 사항이 처리된다는 것만 알 수 있을 뿐이죠.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/command/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Command&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;실행될 기능에 대한 인터페이스&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteCommand&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;실제로 실행되는 기능을 구현&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Invoker&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;기능의 실행을 요청하는 호출자 클래스&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;ConcreteCommand&lt;/code&gt;에서 &lt;code&gt;execute&lt;/code&gt; 메서드를 구현할 때 필요한 클래스&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;작업을 요청하는 클래스와 실제로 작업을 수행하는 클래스를 분리하여 시스템의 결합도를 낮출 수 있음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기존 코드를 수정하지 않고 새로운 기능을 비교적 쉽게 추가할 수 있음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동작자체를 객체화하여 일련의 트랜잭션을 객체단위로 제공할 수 있음&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;구현 및 유지보수해야 하는 클래스가 많아지게 됨.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://johngrib.github.io/wiki/command-pattern/&#34;&gt;기계인간 John Grib Command Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/behavioral/CommandPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>브릿지 패턴</title>
      <link>/programming/design-pattern/%EB%B8%8C%EB%A6%BF%EC%A7%80-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Fri, 25 Jun 2021 17:17:15 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EB%B8%8C%EB%A6%BF%EC%A7%80-%ED%8C%A8%ED%84%B4/</guid>
      <description>브릿지 패턴이란?  구현부와 추상층을 분리한 패턴
구현 뿐만 아니라 추상화 부분까지 변경시켜야 하는 경우에 사용하는 구조적 디자인 패턴.
 구조  Abstraction 추상화된 인터페이스 RefinedAbstraction 정의된 인터페이스를 확장하는 객체 Implementor 구현 클래스의 인터페이스를 정의
Abstraction의 인터페이스와 일치 할 필요는 없다. ConcreteImplementor Implementor의 인터페이스를 구현하고 구체적인 구현한 객체  장점  구현을 인터페이스에 완전히 결합시키지 않음
-&amp;gt; 구현과 추상화된 부분을 분리시킬 수 있음. 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있음 추상화된 부분을 구현한 구상 클래스를 바꿔도 클라이언트에 영향을 끼치지 않음  단점  디자인이 복잡해짐   참고  Head First Design Patterns SLiPP::위키 Bridge Pattern 예제 소스  </description>
      <content>&lt;h2 id=&#34;브릿지-패턴이란&#34;&gt;브릿지 패턴이란?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;구현부와 추상층을 분리한 패턴&lt;/p&gt;
&lt;p&gt;구현 뿐만 아니라 추상화 부분까지 변경시켜야 하는 경우에 사용하는 구조적 디자인 패턴.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/bridge/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Abstraction&lt;/code&gt;
추상화된 인터페이스&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RefinedAbstraction&lt;/code&gt;
정의된 인터페이스를 확장하는 객체&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Implementor&lt;/code&gt;
구현 클래스의 인터페이스를 정의&lt;br&gt;
&lt;code&gt;Abstraction&lt;/code&gt;의 인터페이스와 일치 할 필요는 없다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteImplementor&lt;/code&gt;
&lt;code&gt;Implementor&lt;/code&gt;의 인터페이스를 구현하고 구체적인 구현한 객체&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;구현을 인터페이스에 완전히 결합시키지 않음&lt;br&gt;
-&amp;gt; 구현과 추상화된 부분을 분리시킬 수 있음.&lt;/li&gt;
&lt;li&gt;추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있음&lt;/li&gt;
&lt;li&gt;추상화된 부분을 구현한 구상 클래스를 바꿔도 클라이언트에 영향을 끼치지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;디자인이 복잡해짐&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/display/SLS/Bridge+Pattern&#34;&gt;SLiPP::위키 Bridge Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/structural/BridgePattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>빌더 패턴</title>
      <link>/programming/design-pattern/%EB%B9%8C%EB%8D%94-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Thu, 24 Jun 2021 20:44:04 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EB%B9%8C%EB%8D%94-%ED%8C%A8%ED%84%B4/</guid>
      <description>구조  Builder
Prouduct 객체의 요소들을 생성하기 위한 추상 인터페이스를 정의 ConcreateBuilder
Builder에서 정의해둔 인터페이스를 구현 Director
Builder 인터페이스를 사용하는 객체를 합성 Product
빌더패턴을 이용하여 생성된 인스턴스  왜 사용해야 할까?  빌드 패턴은 객체를 생성하는 작업을 분할 하는 데 도움이 된다 ‎일반적으로 복잡한 만들기 논리를 캡슐화할 수 있다 여러 단계와 절차를 통해 객체가 생성된다.
각 단계 및 절차 별로 독립적인 추상화나 관리를 할 수 있음 물체는 준비가되기 전에 일부 지시된 단계에 의해 관리되어야하며 다른 클라이언트가 사용할 수 있다 ‎ 클라이언트 측에서는 추상 인터페이스만 바라보기에 구현 코드를 쉽게 바꿀 수 있다  이펙티브 자바 - 빌더 패턴 일반적으로 빌더 라고 하면 이쪽을 많이 부른다.</description>
      <content>&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/builder/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;Prouduct&lt;/code&gt; 객체의 요소들을 생성하기 위한 추상 인터페이스를 정의&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreateBuilder&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;Builder&lt;/code&gt;에서 정의해둔 인터페이스를 구현&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Director&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;Builder&lt;/code&gt; 인터페이스를 사용하는 객체를 합성&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Product&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;빌더패턴을 이용하여 생성된 인스턴스&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;왜-사용해야-할까&#34;&gt;왜 사용해야 할까?&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;빌드 패턴은 객체를 생성하는 작업을 분할 하는 데 도움이 된다&lt;/li&gt;
&lt;li&gt;‎일반적으로 복잡한 만들기 논리를 캡슐화할 수 있다&lt;/li&gt;
&lt;li&gt;여러 단계와 절차를 통해 객체가 생성된다.&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;각 단계 및 절차 별로 독립적인 추상화나 관리를 할 수 있음&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;물체는 준비가되기 전에 일부 지시된 단계에 의해 관리되어야하며 다른 클라이언트가 사용할 수 있다 ‎&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;클라이언트 측에서는 추상 인터페이스만 바라보기에 구현 코드를 쉽게 바꿀 수 있다&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;이펙티브-자바---빌더-패턴&#34;&gt;이펙티브 자바 - 빌더 패턴&lt;/h2&gt;
&lt;p&gt;일반적으로 &lt;code&gt;빌더&lt;/code&gt; 라고 하면 이쪽을 많이 부른다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;생성자에 매개변수가 많다면 빌더를 고려하라&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;객체 생성하는 몇가지 패턴이 존재하는데&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;점층적 생성자 패턴&lt;/li&gt;
&lt;li&gt;자바빈 패턴&lt;/li&gt;
&lt;li&gt;빌더 패턴&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;그 중 하나인 빌더 패턴이다&lt;/p&gt;
&lt;p&gt;해당 내용에 대한 글이 아니기에 언급만하고 생략&amp;hellip;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://johngrib.github.io/wiki/builder-pattern/#gof-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4%EC%9D%98-%EB%B9%8C%EB%8D%94-%ED%8C%A8%ED%84%B4&#34;&gt;빌더 패턴&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/creation/BuilderPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>책임 연쇄 패턴</title>
      <link>/programming/design-pattern/%EC%B1%85%EC%9E%84-%EC%97%B0%EC%87%84-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Thu, 24 Jun 2021 15:22:20 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%B1%85%EC%9E%84-%EC%97%B0%EC%87%84-%ED%8C%A8%ED%84%B4/</guid>
      <description>구조도   Handler 요청을 수신하고 처리객체들의 집합에 전달하는 인터페이스
집합의 첫 번째 핸들러에 대한 정보만 가지고 있음
  Concrete handlers 요청을 처리하는 객체
  Client 요청을 전달하는 클라이언트
  책임 연쇄 패턴이란? 명령 객체와 일련의 처리 객체를 포함하는 패턴으로
각각의 처리 객체는 명령 객체를 처리할 수 있는 연산의 집합이고
체인 안의 처리 객체가 핸들할 수 없는 명령은 다음 처리 객체로 넘겨지며 처리된다.
장점  요청을 보낸 쪽하고 받는 쪽을 분리시킬 수 있다 객체에는 사슬의 구조를 몰라도 되고 그 사슬에 들어있는</description>
      <content>&lt;h2 id=&#34;구조도&#34;&gt;구조도&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/chain-of-responsibility/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Handler&lt;/code&gt; 요청을 수신하고 처리객체들의 집합에 전달하는 인터페이스&lt;br&gt;
집합의 첫 번째 핸들러에 대한 정보만 가지고 있음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Concrete handlers&lt;/code&gt; 요청을 처리하는 객체&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Client&lt;/code&gt; 요청을 전달하는 클라이언트&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;책임-연쇄-패턴이란&#34;&gt;책임 연쇄 패턴이란?&lt;/h2&gt;
&lt;p&gt;명령 객체와 일련의 처리 객체를 포함하는 패턴으로&lt;/p&gt;
&lt;p&gt;각각의 처리 객체는 명령 객체를 처리할 수 있는 연산의 집합이고&lt;/p&gt;
&lt;p&gt;체인 안의 처리 객체가 핸들할 수 없는 명령은 다음 처리 객체로 넘겨지며 처리된다.&lt;/p&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;요청을 보낸 쪽하고 받는 쪽을 분리시킬 수 있다&lt;/li&gt;
&lt;li&gt;객체에는 사슬의 구조를 몰라도 되고 그 사슬에 들어있는&lt;br&gt;
다른 객체에 대한 직접적인 레퍼런스를 가질 필요도 없기 때문에&lt;br&gt;
객체를 단순하게 만들 수 있다&lt;/li&gt;
&lt;li&gt;사슬에 들어가는 객체를 바꾸거나 순서를 바꿈으로써 역활을 동적으로 추가/제거할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;실행시 과정을 살펴보거나 디버깅하기 힘들 수 있음&lt;/li&gt;
&lt;li&gt;요청이 반드시 처리된다는 보장이 없음&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참조&#34;&gt;참조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/behavioral/ChainOfResponsibility&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>어댑터 패턴</title>
      <link>/programming/design-pattern/%EC%96%B4%EB%8C%91%ED%84%B0-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Wed, 23 Jun 2021 23:10:43 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%96%B4%EB%8C%91%ED%84%B0-%ED%8C%A8%ED%84%B4/</guid>
      <description>구조도 Client 라이브러리나 외부 시스템을 사용하려는 요소
Adaptee 사용될 라이브러리나 외부 시스템
Target 어댑터가 구현하는 인터페이스
클라이언트는 인터페이스를 통해 어댑터와 연결된 Adaptee를 사용하게 된다.
Adapter Client 와 Adaptee 중간에서 호환성이 없는 둘을 연결하는 역활
어댑터 패턴이란? 한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환합니다.
어댑터를 이용하면 인터페이스 호환성 문제 때문에
같이 쓸 수 없는 클래스를 연결해서 쓸 수 있음.
왜 사용해야 할까? 인터페이스 호환 문제로 같이 쓸 수 없을 경우 사용한다곤 하는데</description>
      <content>&lt;h2 id=&#34;구조도&#34;&gt;구조도&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/adapter/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Client&lt;/code&gt; 라이브러리나 외부 시스템을 사용하려는 요소&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Adaptee&lt;/code&gt; 사용될 라이브러리나 외부 시스템&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Target&lt;/code&gt; 어댑터가 구현하는 인터페이스&lt;/p&gt;
&lt;p&gt;클라이언트는 인터페이스를 통해 어댑터와 연결된 &lt;code&gt;Adaptee&lt;/code&gt;를 사용하게 된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Adapter&lt;/code&gt; &lt;code&gt;Client&lt;/code&gt; 와 &lt;code&gt;Adaptee&lt;/code&gt; 중간에서 호환성이 없는 둘을 연결하는 역활&lt;/p&gt;
&lt;h2 id=&#34;어댑터-패턴이란&#34;&gt;어댑터 패턴이란?&lt;/h2&gt;
&lt;p&gt;한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환합니다.&lt;/p&gt;
&lt;p&gt;어댑터를 이용하면 인터페이스 호환성 문제 때문에&lt;/p&gt;
&lt;p&gt;같이 쓸 수 없는 클래스를 연결해서 쓸 수 있음.&lt;/p&gt;
&lt;h2 id=&#34;왜-사용해야-할까&#34;&gt;왜 사용해야 할까?&lt;/h2&gt;
&lt;p&gt;인터페이스 호환 문제로 같이 쓸 수 없을 경우 사용한다곤 하는데&lt;/p&gt;
&lt;p&gt;왜 써야할까?&lt;/p&gt;
&lt;p&gt;단순하게 사용할 수 있게 수정하면 되지 않을까?&lt;/p&gt;
&lt;h3 id=&#34;__어댑티-쪽을-수정한다고-가정하면__&#34;&gt;&lt;strong&gt;어댑티 쪽을 수정한다고 가정하면&amp;hellip;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;어댑티가 제공받은 라이브러리로써 직접적으로 수정이 불가능할 경우에 문제가 생길 수 있다.&lt;/p&gt;
&lt;p&gt;수정이 가능할 경우 이후 어댑티가 제공자에 의해 수정되는 경우&lt;/p&gt;
&lt;p&gt;해당 수정내용을 반영한 어댑티를 다시 수정해야 한다..&lt;/p&gt;
&lt;h3 id=&#34;__그렇다면-클라이언트-쪽은-어떨까__&#34;&gt;&lt;strong&gt;그렇다면 클라이언트 쪽은 어떨까&amp;hellip;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;클라이언트의 경우 단순한 구조라면 별 문제가 발생하지 않지만&lt;/p&gt;
&lt;p&gt;구조가 복잡해지거나 클라이언트의 연관관계가 많아질 경우&lt;/p&gt;
&lt;p&gt;클라이언트 수정시 다른 곳에서 문제가 발생할 수 있다&lt;/p&gt;
&lt;h3 id=&#34;요약하자면&#34;&gt;요약하자면&lt;/h3&gt;
&lt;p&gt;클라이언트와 어댑티를 수정하지 않고도 사용할 수 있게 해주는 패턴으로&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;수정시 발생할 수 있는 사이드 이펙트를 막게 해준다.&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참조&#34;&gt;참조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/structural/AdapterPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>추상 팩토리 패턴</title>
      <link>/programming/design-pattern/%EC%B6%94%EC%83%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Tue, 22 Jun 2021 16:16:12 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%B6%94%EC%83%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%8C%A8%ED%84%B4/</guid>
      <description>구조도 추상 팩토리 패턴이란? 상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나
독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공하기 위해 사용.
 AbstractFactory
개념적 제품에 대한 객체를 생성하는 연산으로 인터페이스를 정의한다. ConcreteFactory
구체적인 제품에 대한 객체를 생성하는 연산을 구현한다. AbstractProduct
개념적 제품 객체에 대한 인터페이스를 정의한다. ConcreteProduct
구체적으로 팩토리가 생성할 객체를 정의하고, AbstractProduct가 정의하는 인터페이스를 구현한다. Client
AbstractFactory와 AbstractProduct 클래스에 선언된 인터페이스를 사용한다.  언제 사용해야 할까?  객체 생성과 객체를 사용하는 시스템을 독립적으로 구성하기 위해서.</description>
      <content>&lt;h2 id=&#34;구조도&#34;&gt;구조도&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/abstractFactory/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;추상-팩토리-패턴이란&#34;&gt;추상 팩토리 패턴이란?&lt;/h2&gt;
&lt;p&gt;상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나&lt;/p&gt;
&lt;p&gt;독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공하기 위해 사용.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AbstractFactory&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;개념적 제품에 대한 객체를 생성하는 연산으로 인터페이스를 정의한다.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteFactory&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;구체적인 제품에 대한 객체를 생성하는 연산을 구현한다.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AbstractProduct&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;개념적 제품 객체에 대한 인터페이스를 정의한다.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteProduct&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;구체적으로 팩토리가 생성할 객체를 정의하고, &lt;code&gt;AbstractProduct&lt;/code&gt;가 정의하는 인터페이스를 구현한다.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Client&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;AbstractFactory&lt;/code&gt;와 &lt;code&gt;AbstractProduct&lt;/code&gt; 클래스에 선언된 인터페이스를 사용한다.&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;언제-사용해야-할까&#34;&gt;언제 사용해야 할까?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;객체 생성과 객체를 사용하는 시스템을 독립적으로 구성하기 위해서.&lt;/li&gt;
&lt;li&gt;여러 객체 군을 시스템이 사용하기 위해,
다른것으로도 대체를 쉽게 하기 위해서.&lt;/li&gt;
&lt;li&gt;여러 객체 군을 함께 사용할 수 있어야 할때.&lt;/li&gt;
&lt;li&gt;제품에 대한 클래스 라이브러리를 세부 정보를 노출없이 제공하고 싶을 때
&lt;ul&gt;
&lt;li&gt;클래스의 구현으로 제공이 아닌 인터페이스만 노출시키고 싶을 경우.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여러 팩토리에서 객체를 생산하며,&lt;/p&gt;
&lt;p&gt;생산된 객체가 무엇인지 몰라도 객체의 인터페이스만으로도 조작할 수 있음.&lt;/p&gt;
&lt;p&gt;객체를 조합으로 생성할 경우, 유용하게 사용할 수 있을듯하다.&lt;/p&gt;
&lt;p&gt;다만, 패턴 생성시 보일러 플레이트가 한두개가 아닌데.&lt;/p&gt;
&lt;p&gt;인터페이스 수정, 추상 메소드의 추가와 같은 수정사항이 생기는 경우&amp;hellip;&lt;/p&gt;
&lt;p&gt;고민을 좀 해봐야 할듯&amp;hellip;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참조&#34;&gt;참조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://johngrib.github.io/wiki/abstract-factory-pattern/&#34;&gt;기계인간 - Abstract Factory Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/creation/AbstractFactoryPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>디자인 패턴</title>
      <link>/programming/design-pattern/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 21 Jun 2021 17:12:33 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/</guid>
      <description>디자인패턴이란? 앞선 개발자들이 만들어 놓은 공통적으로 발생하는 문제에 대한 재사용 가능한 해결책 이다.
일반적으로 디자인 패턴 이라고 한다면 Gang-Of-Four 가 쓴 디자인패턴 서적의 내용이라고 보면 된다.
&amp;ldquo;디자인패턴이란? 일반적인 문제를 해결하기 위한 문제해결책이다.&amp;rdquo;
이정도까지만 알고 있어도 문제없을듯하다.
그래서 왜 디자인 패턴을 알아야 하나?   앞서 말한것과 같이 일반적으로 발생하는 문제 의 해결책으로 사용할 수 있기 때문에
  다른 개발자와 소통하기 편해진다.
  1번의 경우 앞에서 나온 내용이기에 생략한다.</description>
      <content>&lt;h1 id=&#34;디자인패턴이란&#34;&gt;디자인패턴이란?&lt;/h1&gt;
&lt;p&gt;앞선 개발자들이 만들어 놓은 &lt;strong&gt;공통적으로 발생하는 문제에 대한 재사용 가능한 해결책&lt;/strong&gt; 이다.&lt;/p&gt;
&lt;p&gt;일반적으로 &lt;strong&gt;디자인 패턴&lt;/strong&gt; 이라고 한다면 &lt;code&gt;Gang-Of-Four&lt;/code&gt; 가 쓴 디자인패턴 서적의 내용이라고 보면 된다.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;&lt;strong&gt;디자인패턴이란?  일반적인 문제를 해결하기 위한 문제해결책이다.&lt;/strong&gt;&amp;rdquo;&lt;/p&gt;
&lt;p&gt;이정도까지만 알고 있어도 문제없을듯하다.&lt;/p&gt;
&lt;h2 id=&#34;그래서-왜-디자인-패턴을-알아야-하나&#34;&gt;그래서 왜 디자인 패턴을 알아야 하나?&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;앞서 말한것과 같이 &lt;strong&gt;일반적으로 발생하는 문제&lt;/strong&gt; 의 해결책으로 사용할 수 있기 때문에&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다른 개발자와 소통하기 편해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1번의 경우 앞에서 나온 내용이기에 생략한다.&lt;/p&gt;
&lt;p&gt;2번의 경우, 다르게 생각하는 경우도 있겠지만&lt;/p&gt;
&lt;p&gt;디자인 패턴으로 소통을 한다면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;해당 패턴에 사용되는 장점, 단점 등 내포되는 내용을 포괄적으로 소통가능&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;장황하게 길어지는 설명을 단순한 단어로 처리할 수 있음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;좀 더 프로그램의 구조에 대해 살펴볼 수 있게 됨&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;등등&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이와 같은 장점들이 있다고 알려져 있다&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;좀-더-알아보자&#34;&gt;좀 더 알아보자&lt;/h2&gt;
&lt;p&gt;일반적으로 통용되는 디자인 패턴을 일컫는&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Gang-Of-Four&lt;/code&gt;의 디자인패턴에서는 여러가지 종류의 디자인 패턴을 소개하고 있다.&lt;/p&gt;
&lt;p&gt;각각의 패턴은 여러가지 종류로 그룹화할 수 있겠지만&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;        
        &lt;strong class=&#34;tx-royalblue&#34;&gt;생성 패턴(Creational Pattern)&lt;/strong&gt;&lt;/br&gt;
        &lt;sub class=&#34;tx-sub&#34;&gt;객체의 생성을 다루는 패턴&lt;/sub&gt;        
    &lt;/li&gt; 
    &lt;li&gt;
        &lt;strong class=&#34;tx-teal&#34;&gt;구조 패턴(Structural Pattern)&lt;/strong&gt;&lt;/br&gt;
        &lt;sub class=&#34;tx-sub&#34;&gt;객체의 구성을 다루는 패턴&lt;/sub&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;strong class=&#34;tx-orange&#34;&gt;행동 패턴(Behavioral Pattern)&lt;/strong&gt;&lt;/br&gt;
        &lt;sub class=&#34;tx-sub&#34;&gt;객체의 행동, 또는 객체 간의 상호작용을 다루는 패턴&lt;/sub&gt;
    &lt;/li&gt;
&lt;/ol&gt; 
일반적으로 사용되는 패턴들을 3가지로 구분하자면 다음과 같다
&lt;table style=&#34;text-align: center;&#34;&gt;
&lt;thead&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;strong class=&#34;tx-royalblue&#34;&gt;
                생성 패턴(Creational Pattern)
            &lt;/strong&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;strong class=&#34;tx-teal&#34;&gt;
            구조패턴(Structural Pattern)
            &lt;/strong&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;strong class=&#34;tx-orange&#34;&gt;
            행동 패턴(Behavioral Pattern)
            &lt;/strong&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
            &lt;span&gt;추상 팩토리 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Abstract Factory Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;어댑터 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Adapter Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;책임 연쇄 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Chain Of Responsibility&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
            &lt;span&gt;빌더 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Builder Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;브릿지 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Bridge Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;            
            &lt;span&gt;커맨드 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Command Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
            &lt;span&gt;팩토리 메소드 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Factory Method Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;컴포짓 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Composite Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;인터프리터 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Interpreter Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
            &lt;span&gt;프로토타입 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Prototype Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;데코레이터 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Decorator Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;이터레이터 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Iterator Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
            &lt;span&gt;싱글톤 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Singleton Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;퍼사드 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Facade Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;중재자 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Mediator Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;플라이웨이트 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Flyweight Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;메멘토 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Memento Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;프록시 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Proxy Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;옵저버 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Observer Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;상태 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;State Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;전략 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Strategy Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;방문자 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Visitor Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;템플릿 메소드 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Template Method Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;디자인 패턴이란 말그대로 패턴이기에 많은 패턴이 존재하기에&amp;hellip; 표기되지 않은 패턴이 있을 수 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참조&#34;&gt;참조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yes24.com/Product/Goods/17525598&#34;&gt;GoF의 디자인패턴&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;amp;ejkGb=KOR&amp;amp;barcode=9788979143409&#34;&gt;Head First Design Patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>월간 코드 챌린지   삼각 달팽이</title>
      <link>/algorithm/%EC%9B%94%EA%B0%84-%EC%BD%94%EB%93%9C-%EC%B1%8C%EB%A6%B0%EC%A7%80-%EC%82%BC%EA%B0%81-%EB%8B%AC%ED%8C%BD%EC%9D%B4/</link>
      <pubDate>Thu, 17 Jun 2021 22:03:21 +0900</pubDate>
      
      <guid>/algorithm/%EC%9B%94%EA%B0%84-%EC%BD%94%EB%93%9C-%EC%B1%8C%EB%A6%B0%EC%A7%80-%EC%82%BC%EA%B0%81-%EB%8B%AC%ED%8C%BD%EC%9D%B4/</guid>
      <description>문제 본문의 설명이 매우 직관적이고 예시 그림과 함께 보자
정수 n이 매개변수로 주어집니다.
다음 그림과 같이 밑변의 길이와 높이가 n인 삼각형에서
맨 위 꼭짓점부터 반시계 방향으로 달팽이 채우기를 진행한 후,
첫 행부터 마지막 행까지
모두 순서대로 합친 새로운 배열을 return 하도록 solution 함수를 완성해주세요.
이와 같이 n 을 한 변의 길이로 하는 삼각형모양의 배열에서 값을 채워나가면 되는 문제다
그래서 이걸 어떻게 구현을 해야할까?
 풀이 먼저 삼각형 모양의 배열을 코드상에서 어떻게 나타낼까?</description>
      <content>&lt;p&gt;문제 본문의 설명이 매우 직관적이고 예시 그림과 함께 보자&lt;/p&gt;
&lt;p&gt;정수 n이 매개변수로 주어집니다.&lt;/p&gt;
&lt;p&gt;다음 그림과 같이 밑변의 길이와 높이가 &lt;code&gt;n&lt;/code&gt;인 삼각형에서&lt;/p&gt;
&lt;p&gt;맨 위 꼭짓점부터 반시계 방향으로 달팽이 채우기를 진행한 후,&lt;/p&gt;
&lt;p&gt;첫 행부터 마지막 행까지&lt;/p&gt;
&lt;p&gt;모두 순서대로 합친 새로운 배열을 &lt;code&gt;return&lt;/code&gt; 하도록 &lt;code&gt;solution&lt;/code&gt; 함수를 완성해주세요.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/algorithm/programmers/problem68645/examples.png&#34; alt=&#34;example.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;이와 같이 &lt;code&gt;n&lt;/code&gt; 을 한 변의 길이로 하는 삼각형모양의 배열에서 값을 채워나가면 되는 문제다&lt;/p&gt;
&lt;p&gt;그래서 이걸 어떻게 구현을 해야할까?&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;풀이&#34;&gt;풀이&lt;/h2&gt;
&lt;p&gt;먼저 &lt;code&gt;삼각형 모양의 배열을 코드상에서 어떻게 나타낼까? &lt;/code&gt; 에 대해서 인데&lt;/p&gt;
&lt;p&gt;2차원 배열이 일반적으로 도형의 각 위치별 값을 표현하기 쉽기에 2차원 배열로 표현하기로 했다.&lt;/p&gt;
&lt;p&gt;다만, 정말로 삼각형 모양대로 배열을 만들려면 처리시에 계산하기가 힘들듯하여,&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 값이 4인 삼각형 예시로 이차원 배열을 아래와 같이 &lt;code&gt;n&lt;/code&gt;의 크기대로 생성하여 처리하였다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/algorithm/programmers/problem68645/examples3.png&#34; alt=&#34;example3.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;그렇다면 이제 위에 그림과 같이 처리할 배열이 주어졌을때 안에 값을 넣어야 하는데&lt;/p&gt;
&lt;p&gt;아래 그림의 화살표를 참고하여 보자면&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/algorithm/programmers/problem68645/examples4.png&#34; alt=&#34;example4.png&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(0,0)&lt;/code&gt; 에서 시작하여, &lt;code&gt;(3,0)&lt;/code&gt;까지&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(3,1)&lt;/code&gt; 에서 시작하여, &lt;code&gt;(3,3)&lt;/code&gt;까지&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(2,2)&lt;/code&gt; 에서 시작하여, &lt;code&gt;(1,1)&lt;/code&gt;까지&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(2,1)&lt;/code&gt;값을 채워 넣으며 마무리.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;좀 더 구현하기 쉽게 표현 해보자면&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(0,0)&lt;/code&gt;에서 시작하여 아래로 이동하며 값을 추가하면서 진행&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;마지막으로 값을 입력한 부분에서 우측 방향으로 값을 추가하면서 진행&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;마지막 부분에서 대각선 방향으로 값을 추가하면서 진행&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;더이상 진행하면서 값을 추가할 수 없을 경우 종료&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;정도로 표현할 수 있겠다.&lt;/p&gt;
&lt;p&gt;이차원 배열을 순회하면서&lt;/p&gt;
&lt;p&gt;&lt;code&gt;값을 추가할 수 없는 경우&lt;/code&gt; 와 &lt;code&gt;해당 진행방향으로 진행할 수 없는 경우&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;진행 방향을 &lt;code&gt;아래&lt;/code&gt;, &lt;code&gt;오른쪽&lt;/code&gt;, &lt;code&gt;좌상향 대각선&lt;/code&gt; 으로 돌아가면서 진행하기에&lt;/p&gt;
&lt;p&gt;해당 방향 표현을 위해 배열 두개로 진행 방향에 대한 정보를 담았다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; dx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;};&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; dy &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이후에는 이차원 배열을 &lt;code&gt;(0,0)&lt;/code&gt; 부터 진행 방향대로 순회하면서 값을 넣어주면 처리된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;값을 추가할 수 없는 경우&lt;/code&gt; 판단의 경우, 마지막으로 입력되는 값은 등비 수열의 합과 같으므로&lt;/p&gt;
&lt;p&gt;$$ \sum_{k=1}^n k = \frac{n(n+1)}{2}$$&lt;/p&gt;
&lt;p&gt;로 표현할 수 있다.&lt;/p&gt;
&lt;p&gt;마지막으로 입력되는 값보다 다음 입력할 값이 클 경우&lt;/p&gt;
&lt;p&gt;&lt;code&gt;값을 추가할 수 없는 경우&lt;/code&gt; 중 하나로 판단하여 더이상 추가하지 않고 종료한다.&lt;/p&gt;
&lt;p&gt;마지막으로 결과값을 일차원 배열에 담아 전달하여야 하는데&lt;/p&gt;
&lt;p&gt;이차원 배열을 순회하며, 값이 입력된 값을 순차적으로 담아서 처리하였다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;// 2차원 배열 순회시 방향 지정용
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; dx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;};&lt;/span&gt;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; dy &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;};&lt;/span&gt;

	&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;

        &lt;span style=&#34;color:#75715e&#34;&gt;// 위에 수식대로 수정하면 좀 더 깔끔...
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 코드 작성시 단순히 반복을 통해 도출하였음
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; maxValue &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
			maxValue &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
		&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[][]&lt;/span&gt; map &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;n&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;n&lt;span style=&#34;color:#f92672&#34;&gt;];&lt;/span&gt;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 시작 좌표 설정
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 시작 값 설정
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; startValue &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 순회 시작 방향 설정
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; rotate &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 2차원 배열 순회
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;startValue &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; maxValue&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#75715e&#34;&gt;// 배열의 크기를 넘어가거나
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 해당 부분의 값이 이미 있을 경우
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 해당 방향으로 진행을 멈춤
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;((&lt;/span&gt;y &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;map&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;y&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
				map&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;y&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; startValue&lt;span style=&#34;color:#f92672&#34;&gt;++;&lt;/span&gt;
				y &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; dy&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;rotate &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; 3&lt;span style=&#34;color:#f92672&#34;&gt;];&lt;/span&gt;
				x &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; dx&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;rotate &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; 3&lt;span style=&#34;color:#f92672&#34;&gt;];&lt;/span&gt;
			&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#75715e&#34;&gt;// while문으로 마지막 진행을 취소하기 위해서 추가
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;			y &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; dy&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;rotate &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; 3&lt;span style=&#34;color:#f92672&#34;&gt;];&lt;/span&gt;
			x &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; dx&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;rotate &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; 3&lt;span style=&#34;color:#f92672&#34;&gt;];&lt;/span&gt;
            &lt;span style=&#34;color:#75715e&#34;&gt;// 진행 방향 변경
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;			rotate&lt;span style=&#34;color:#f92672&#34;&gt;++;&lt;/span&gt;
            &lt;span style=&#34;color:#75715e&#34;&gt;// 다음 진행을 위해 검색 좌표 변경
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;			y &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; dy&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;rotate &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; 3&lt;span style=&#34;color:#f92672&#34;&gt;];&lt;/span&gt;
			x &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; dx&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;rotate &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; 3&lt;span style=&#34;color:#f92672&#34;&gt;];&lt;/span&gt;
		&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 최대값의 크기가 결과값 배열의 크기
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; answer &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;maxValue&lt;span style=&#34;color:#f92672&#34;&gt;];&lt;/span&gt;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 2차원 배열을 순회하면서 결과값 처리
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
			&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; j&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#75715e&#34;&gt;// 값이 입력된 경우만 추가하여 처리
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;				&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;map&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; 
					answer&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;idx&lt;span style=&#34;color:#f92672&#34;&gt;++]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; map&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;j&lt;span style=&#34;color:#f92672&#34;&gt;];&lt;/span&gt;
				&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
			&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
		&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; answer&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
	&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;좀 더 깔끔하게 코드를 짜도록 노력하자&amp;hellip;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://programmers.co.kr/learn/courses/30/lessons/68645&#34;&gt;문제 링크&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/algorithm/blob/main/programmers30_68645/src/main/java/study/problem/Solution.java&#34;&gt;풀이 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>월간 코드 챌린지 - 괄호 회전하기</title>
      <link>/algorithm/%EC%9B%94%EA%B0%84-%EC%BD%94%EB%93%9C-%EC%B1%8C%EB%A6%B0%EC%A7%80-%EA%B4%84%ED%98%B8-%ED%9A%8C%EC%A0%84%ED%95%98%EA%B8%B0/</link>
      <pubDate>Thu, 17 Jun 2021 21:35:27 +0900</pubDate>
      
      <guid>/algorithm/%EC%9B%94%EA%B0%84-%EC%BD%94%EB%93%9C-%EC%B1%8C%EB%A6%B0%EC%A7%80-%EA%B4%84%ED%98%B8-%ED%9A%8C%EC%A0%84%ED%95%98%EA%B8%B0/</guid>
      <description>문자열에 대해 괄호 검사 를 하는 매우 간단한 문제로
추가적인 기능으로 해당 문자열을 회전하는 기능 을 추가적으로 요구한다.
단순한 기능 두 요구사항 구현으로 완료되는 문제
 풀이 먼저 문자열을 회전하는 기능을 구현해보자
회전이라고는 하지만, 전체 문자열중 맨 앞 문자를 맨뒤에 붙혀주면 되는 간단한 기능이다
private String rotate(String input) { StringBuilder sb = new StringBuilder(input.substring(1)); sb.append(input.charAt(0)); return sb.toString(); } 다음으로는 문자열이 올바른 괄호 문자열인지 확인하는 기능을 구현해보자
대부분의 괄호가 닫혀있는지 확인할때는 스택을 쓰면 편하게 구현이 가능하다</description>
      <content>&lt;p&gt;&lt;strong&gt;문자열에 대해 괄호 검사&lt;/strong&gt; 를 하는 매우 간단한 문제로&lt;/p&gt;
&lt;p&gt;추가적인 기능으로 해당 &lt;strong&gt;문자열을 회전하는 기능&lt;/strong&gt; 을 추가적으로 요구한다.&lt;/p&gt;
&lt;p&gt;단순한 기능 두 요구사항 구현으로 완료되는 문제&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;풀이&#34;&gt;풀이&lt;/h2&gt;
&lt;p&gt;먼저 문자열을 회전하는 기능을 구현해보자&lt;/p&gt;
&lt;p&gt;회전이라고는 하지만, 전체 문자열중 맨 앞 문자를 맨뒤에 붙혀주면 되는 간단한 기능이다&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; String &lt;span style=&#34;color:#a6e22e&#34;&gt;rotate&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;String input&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    StringBuilder sb &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; StringBuilder&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;input&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;substring&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;));&lt;/span&gt;
    sb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;append&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;input&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;charAt&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;));&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; sb&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;toString&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;다음으로는 문자열이 올바른 괄호 문자열인지 확인하는 기능을 구현해보자&lt;/p&gt;
&lt;p&gt;대부분의 괄호가 닫혀있는지 확인할때는 스택을 쓰면 편하게 구현이 가능하다&lt;/p&gt;
&lt;p&gt;입력 문자열을 문자별로 순회하면서&lt;/p&gt;
&lt;p&gt;각 괄호 문자별(&lt;code&gt;( )&lt;/code&gt; , &lt;code&gt;{ }&lt;/code&gt; , &lt;code&gt;[ ]&lt;/code&gt;)로 확인, 이전 문자가 상응하는 문자의 경우에만 스택에서 제거한다&lt;/p&gt;
&lt;p&gt;입력 문자열은 괄호들로 이루어진 문자열이기에&lt;/p&gt;
&lt;p&gt;이외의 문자의 경우 새로운 괄호로 생각하여, 스택에서 추가한다.&lt;/p&gt;
&lt;p&gt;모든 문자열을 순회하였을때, 올바른 괄호 문자열의 경우 스택이 비워져 있어야 한다.&lt;/p&gt;
&lt;p&gt;아래는 구현 해당 기능을 구한 예시이다&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isBracketsClosed&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;String input&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    Stack&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Character&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; stack &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Stack&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; input&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;toCharArray&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;())&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;switch&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;c&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;)&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(!&lt;/span&gt;stack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;isEmpty&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; stack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;peek&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;(&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                    stack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;pop&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
                &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;}&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(!&lt;/span&gt;stack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;isEmpty&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; stack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;peek&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;{&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                    stack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;pop&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
                &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;]&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(!&lt;/span&gt;stack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;isEmpty&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; stack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;peek&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;[&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
                    stack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;pop&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
                &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
                stack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;c&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; stack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;isEmpty&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://programmers.co.kr/learn/courses/30/lessons/76502&#34;&gt;문제 링크&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/algorithm/blob/main/programmers30_76502/src/main/java/study/problem/Solution.java&#34;&gt;풀이 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>프로그래머스 - 카펫</title>
      <link>/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%B9%B4%ED%8E%AB/</link>
      <pubDate>Sat, 12 Jun 2021 20:07:42 +0900</pubDate>
      
      <guid>/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%B9%B4%ED%8E%AB/</guid>
      <description>문제부터 살펴보자
카펫에 속한 두 타일 색으로 전체 카펫 크기를 도출하면 되는 문제
입력값으로는 두 타일 색인, 갈색 타일, 노란색 타일, 각각의 갯수가 주어진다
중앙의 타일은 항상 노란 타일 이며, 바깥 부분은 갈색 타일 로 둘러쌓여진 형태
 풀이 먼저 갈색 타일에 대해 좀 더 살펴보자
갈색 타일 은 전체 카펫의 테두리 부분이며
전체 카펫 타일 갯수를 $ 가로 X 세로 $ 라 칭할 수 있을 때
갈색 타일 갯수는</description>
      <content>&lt;p&gt;문제부터 살펴보자&lt;/p&gt;
&lt;p&gt;&lt;code&gt;카펫&lt;/code&gt;에 속한 &lt;code&gt;두 타일 색&lt;/code&gt;으로 전체 카펫 크기를 도출하면 되는 문제&lt;/p&gt;
&lt;p&gt;입력값으로는 두 타일 색인, 갈색 타일, 노란색 타일, 각각의 갯수가 주어진다&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;중앙의 타일은 항상 노란 타일&lt;/strong&gt; 이며, &lt;strong&gt;바깥 부분은 갈색 타일&lt;/strong&gt; 로 둘러쌓여진 형태&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;풀이&#34;&gt;풀이&lt;/h2&gt;
&lt;p&gt;먼저 갈색 타일에 대해 좀 더 살펴보자&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;갈색 타일&lt;/strong&gt; 은 &lt;strong&gt;전체 카펫의 테두리&lt;/strong&gt; 부분이며&lt;/p&gt;
&lt;p&gt;전체 카펫 타일 갯수를 $ 가로 X 세로 $ 라 칭할 수 있을 때&lt;/p&gt;
&lt;p&gt;갈색 타일 갯수는&lt;/p&gt;
&lt;p&gt;$$ 갈색 타일 갯수 = 2 X ( 가로 + 세로) - 4 = (가로 + 세로 + 가로 + 세로) - 4$$&lt;/p&gt;
&lt;p&gt;여기서 &lt;code&gt;-4&lt;/code&gt;를 한 이유는 가로 갯수 세로 갯수를 더했을 경우,&lt;/p&gt;
&lt;p&gt;모서리의 갯수를 중복해서 더하게 되므로 각 모서리의 갯수를 빼주었다.&lt;/p&gt;
&lt;p&gt;그렇다면 노란 타일도 같은 방식으로 표현해보자&lt;/p&gt;
&lt;p&gt;노란 타일의 경우 전체 카펫의 중앙 부분으로&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;전체 타일&lt;/strong&gt; 에서 &lt;strong&gt;테두리 부분(갈색 타일)&lt;/strong&gt; 제외한 나머지 부분으로&lt;/p&gt;
&lt;p&gt;$$ 노란 타일 갯수 = 가로 X 세로 - (2 X ( 가로 + 세로) -4) $$&lt;/p&gt;
&lt;p&gt;로도 표현할 수 있으나 좀 더 보기 편하게 바꿔보자&lt;/p&gt;
&lt;p&gt;$$ 노란 타일 갯수 = (가로 - 2) X (세로 - 2)$$&lt;/p&gt;
&lt;p&gt;이와 같은 이유가 나온 이유는&lt;/p&gt;
&lt;p&gt;테두리 부분을 제외하기 때문에 기존 카펫의 &lt;code&gt;가로&lt;/code&gt; , &lt;code&gt;세로&lt;/code&gt; 길이에서 테두리 크기 만큼 제외하면&lt;/p&gt;
&lt;p&gt;나머지 노란 타일의 범위인 사각형의 &lt;code&gt;가로&lt;/code&gt;, &lt;code&gt;세로&lt;/code&gt; 길이가 되기에&lt;/p&gt;
&lt;p&gt;기존 카펫 길이에서 각각 &lt;code&gt;-2&lt;/code&gt; 만큼 빼주어 계산한다.&lt;/p&gt;
&lt;p&gt;이와 같은 표현식으로 계산을 편하게 하기 위해 다음과 같은 식을 표현할 수 있다.&lt;/p&gt;
&lt;p&gt;$$ (가로 + 세로) = (갈색 타일 + 4) / 2 $$&lt;/p&gt;
&lt;p&gt;이제 나온 표현식으로 가로+세로 범위 내에서 순회하면서 각 표현식을 검사하면서 확인하면 끝&lt;/p&gt;
&lt;p&gt;아래는 풀이 코드 예시&lt;/p&gt;
&lt;p&gt;식 도출 외에는 간단한편&amp;hellip;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; brown&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; yellow&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; answer &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;2&lt;span style=&#34;color:#f92672&#34;&gt;];&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; borderSize &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;brown &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 4&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; 2&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 가로 + 세로 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 3&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; borderSize&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// i 가로 , j 세로
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 가로 + 세로 길이를 유추하였기 때문에 해당 조건에 맞는 범위 내에서 순회 처리
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; borderSize &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; 
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 문제상 조건으로 추가
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 노란 타일 갯수 표현 식
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; isYellowCnt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 2&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 2&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt; 
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;yellow &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; isYellowCnt&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 표현식이 모두 맞을 경우 정답처리.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            answer&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; j&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
            answer&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; answer&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://programmers.co.kr/learn/courses/30/lessons/42842&#34;&gt;문제 링크&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/algorithm/blob/main/programmers30_42842/src/main/java/study/problem/Solution.java&#34;&gt;풀이 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>2021 데브 매칭   행렬 테두리 회전하기</title>
      <link>/algorithm/2021-%EB%8D%B0%EB%B8%8C-%EB%A7%A4%EC%B9%AD-%ED%96%89%EB%A0%AC-%ED%85%8C%EB%91%90%EB%A6%AC-%ED%9A%8C%EC%A0%84%ED%95%98%EA%B8%B0/</link>
      <pubDate>Sat, 12 Jun 2021 19:30:36 +0900</pubDate>
      
      <guid>/algorithm/2021-%EB%8D%B0%EB%B8%8C-%EB%A7%A4%EC%B9%AD-%ED%96%89%EB%A0%AC-%ED%85%8C%EB%91%90%EB%A6%AC-%ED%9A%8C%EC%A0%84%ED%95%98%EA%B8%B0/</guid>
      <description>데브 매칭 지원시 실제론 못풀었던 문제&amp;hellip;
앞에 문제나 뒤에 문제에 너무 시간을 소비했었다.
이제 와서 풀어보니, 무난하게 풀릴듯.
먼저 문제 설명을 하자면
예시로 $ 6 X 6 $ 사이즈의 행렬이 있다고 할때
아래와 같은 그림처럼 표기할 수 있다.
이때 각 행렬 좌표 두개의 쌍으로 이루어진 요구사항 (문제상에서는 query) 에 맞춰
해당 좌표 내에 행렬 값들을 시계 방향으로 회전시킨다.
아래 그림은 (2, 2), (5, 4) 를 기준으로 했을 때 회전 예시이다.</description>
      <content>&lt;p&gt;데브 매칭 지원시 실제론 못풀었던 문제&amp;hellip;&lt;/p&gt;
&lt;p&gt;앞에 문제나 뒤에 문제에 너무 시간을 소비했었다.&lt;/p&gt;
&lt;p&gt;이제 와서 풀어보니, 무난하게 풀릴듯.&lt;/p&gt;
&lt;p&gt;먼저 문제 설명을 하자면&lt;/p&gt;
&lt;p&gt;예시로 $ 6 X 6 $  사이즈의 행렬이 있다고 할때&lt;/p&gt;
&lt;p&gt;아래와 같은 그림처럼 표기할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/algorithm/programmers/problem77485/grid_example.png&#34; alt=&#34;grid_example.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;이때 각 행렬 좌표 두개의 쌍으로 이루어진 요구사항 (문제상에서는 query) 에 맞춰&lt;/p&gt;
&lt;p&gt;해당 좌표 내에 행렬 값들을 시계 방향으로 회전시킨다.&lt;/p&gt;
&lt;p&gt;아래 그림은 (2, 2), (5, 4) 를 기준으로 했을 때 회전 예시이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/algorithm/programmers/problem77485/rotation_example.png&#34; alt=&#34;rotation_example.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;이러한 요구사항들로 행렬을 회전시킨뒤 이동한 값중 최소값을 반환하면 되는 문제&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;요구사항대로 행렬을 회전&lt;/li&gt;
&lt;li&gt;회전중에 값을 체크하여 가장 작은 값만 도출&lt;/li&gt;
&lt;li&gt;요구 사항별로 반복&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;으로 완료되는 문제.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;풀이&#34;&gt;풀이&lt;/h2&gt;
&lt;p&gt;회전이라고 해서 복잡하게 생각할 필요 없이,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;목표 가장 상위 열&lt;/strong&gt; 을 &lt;strong&gt;우측&lt;/strong&gt; 으로 이동&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;목표 가장 우측 행&lt;/strong&gt; 을 &lt;strong&gt;아래&lt;/strong&gt; 로 이동&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;목표 가장 하위 열&lt;/strong&gt; 을 &lt;strong&gt;좌측&lt;/strong&gt; 으로 이동&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;목표 가장 좌측 행&lt;/strong&gt; 을 &lt;strong&gt;상단&lt;/strong&gt; 으로 이동&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;으로 나누어서 생각하면 편할 듯 싶다.&lt;/p&gt;
&lt;p&gt;그렇다면 예시로 &lt;code&gt;목표 가장 상위 열을 우측으로 이동&lt;/code&gt; 같은 경우에&lt;/p&gt;
&lt;p&gt;&lt;code&gt;목표 가장 상위 열&lt;/code&gt; 과 &lt;code&gt;우측으로 이동&lt;/code&gt; 을 구현하여야 하는데&lt;/p&gt;
&lt;p&gt;&lt;code&gt;목표 가장 상위 열&lt;/code&gt; 의 경우&lt;/p&gt;
&lt;p&gt;요구사항인 &lt;code&gt;query&lt;/code&gt;를 &lt;code&gt;[(x1, y1), (x2, y2)]&lt;/code&gt; 표기할 수 있을때&lt;/p&gt;
&lt;p&gt;&lt;code&gt;목표 가장 상위 열&lt;/code&gt; 은 &lt;code&gt;(*, y1)&lt;/code&gt; 이다&lt;/p&gt;
&lt;p&gt;이때 &lt;code&gt;우측으로 이동&lt;/code&gt;의 이동 범위 지정을 해줘야 하는데&lt;/p&gt;
&lt;p&gt;이동 범위는 &lt;code&gt;x1 ~ x2&lt;/code&gt; 까지 이다&lt;/p&gt;
&lt;p&gt;이와 같은 방식으로 나머지 부분도 구현을 진행하면 해결되는 문제&lt;/p&gt;
&lt;p&gt;나머지는 사소한 것들이 남아 있는데,&lt;/p&gt;
&lt;p&gt;내가 푼 방식의 경우 &lt;code&gt;이차원 배열&lt;/code&gt;을 통한 행렬을 표현하였는데, 인덱스가 0부터 시작이기에&lt;/p&gt;
&lt;p&gt;요구사항 &lt;code&gt;query&lt;/code&gt;의 행렬과 값을 일치시키기 위해 0번 행과 0열을 넣은 &lt;code&gt;이차원 배열&lt;/code&gt;을 생성하였다.&lt;/p&gt;
&lt;p&gt;마지막으로 회전 기능 구현 코드이다.&lt;/p&gt;
&lt;p&gt;사용할 행렬 &lt;code&gt;이차원 배열&lt;/code&gt; 과, 요구사항을 구현한 클래스인 &lt;code&gt;Query&lt;/code&gt;를 사용하여 구현하였다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;rotate&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[][]&lt;/span&gt; map&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; Query query&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; startPoint &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; map&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;];&lt;/span&gt;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; min &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; startPoint&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
		&lt;span style=&#34;color:#75715e&#34;&gt;//상단 우측으로 | a.x -&amp;gt; b.x , a.y 그대로
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; x&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
			map&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; map&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;];&lt;/span&gt;
			min &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Math&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;min&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;min&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; map&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]);&lt;/span&gt;
		&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
		&lt;span style=&#34;color:#75715e&#34;&gt;//우변 하단으로 | b.x 그대로, a.y -&amp;gt; b.y
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; y&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
			map&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;y&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; map&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;y &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;];&lt;/span&gt;
			min &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Math&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;min&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;min&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; map&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;y&lt;span style=&#34;color:#f92672&#34;&gt;]);&lt;/span&gt;
		&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

		&lt;span style=&#34;color:#75715e&#34;&gt;// 하단 좌측으로 | b.x -&amp;gt; a.x | b.y 그대로
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; x&lt;span style=&#34;color:#f92672&#34;&gt;--)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
			map&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; map&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;];&lt;/span&gt;
			min &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Math&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;min&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;min&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; map&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]);&lt;/span&gt;
		&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

		&lt;span style=&#34;color:#75715e&#34;&gt;// 자변 위쪽으로 | a.x 그대로 | b.y -&amp;gt; a.y
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; y&lt;span style=&#34;color:#f92672&#34;&gt;--)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
			map&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;y&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; map&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;y &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;];&lt;/span&gt;
			min &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Math&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;min&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;min&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; map&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;y&lt;span style=&#34;color:#f92672&#34;&gt;]);&lt;/span&gt;
		&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
		map&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;][&lt;/span&gt;query&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; startPoint&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; min&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
	&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://programmers.co.kr/learn/courses/30/lessons/77485&#34;&gt;문제 링크&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/algorithm/blob/main/programmers30_77485/src/main/java/study/problem/Solution.java&#34;&gt;문제 풀이 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>2021 카카오 블라인드   메뉴 리뉴얼</title>
      <link>/algorithm/2021-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C-%EB%A9%94%EB%89%B4-%EB%A6%AC%EB%89%B4%EC%96%BC/</link>
      <pubDate>Thu, 10 Jun 2021 02:36:29 +0900</pubDate>
      
      <guid>/algorithm/2021-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C-%EB%A9%94%EB%89%B4-%EB%A6%AC%EB%89%B4%EC%96%BC/</guid>
      <description>문제 본문이 굉장히 긴편인데, 한눈에 들어오지도 않아 요구하는 바가 무엇인지 바로 파악하기가 힘들었다.
문제의 요구사항으로는
 문자열에 대해 각 문자로 만들 수 있는 문자열 조합 도출 문자열 조합에 대한 갯수 도출 가장 많이 나온 조합에 대해 알파벳 순으로 출력  비교적 쉬운 수준으로 보이나, 위에서 말했다싶이 문제 본문을 읽고 바로 요구사항이 떠오르질 않는다&amp;hellip;
문제 해결을 위해서 좀 더 풀어서 써보자면&amp;hellip;
 입력으로 받은 각 손님 별 주문 (문자열) 에 대해 부분 문자열 조합 생성 각 부분 문자열에 대한 카운트 저장 및 업데이트 목표 코스 크기 (int) 에 대해 가장 많이 호출된 부분 문자열 찾기 결과 반환을 위해 알파벳 순으로 정렬  정도로 문자열에 대해 목표 크기에 맞는 부분 문자열 조합을 생성 후</description>
      <content>&lt;p&gt;문제 본문이 굉장히 긴편인데, 한눈에 들어오지도 않아 요구하는 바가 무엇인지 바로 파악하기가 힘들었다.&lt;/p&gt;
&lt;p&gt;문제의 요구사항으로는&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;문자열에 대해 각 문자로 만들 수 있는 문자열 조합 도출&lt;/li&gt;
&lt;li&gt;문자열 조합에 대한 갯수 도출&lt;/li&gt;
&lt;li&gt;가장 많이 나온 조합에 대해 알파벳 순으로 출력&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;비교적 쉬운 수준으로 보이나, 위에서 말했다싶이 문제 본문을 읽고 바로 요구사항이 떠오르질 않는다&amp;hellip;&lt;/p&gt;
&lt;p&gt;문제 해결을 위해서 좀 더 풀어서 써보자면&amp;hellip;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;입력으로 받은 각 손님 별 주문 (문자열) 에 대해 &lt;strong&gt;부분 문자열 조합 생성&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;각 부분 문자열에 대한 카운트 저장 및 업데이트&lt;/li&gt;
&lt;li&gt;목표 코스 크기 (int) 에 대해 &lt;strong&gt;가장 많이 호출된 부분 문자열&lt;/strong&gt; 찾기&lt;/li&gt;
&lt;li&gt;결과 반환을 위해 &lt;strong&gt;알파벳 순으로 정렬&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;정도로 문자열에 대해 목표 크기에 맞는 부분 문자열 조합을 생성 후&lt;/p&gt;
&lt;p&gt;추후 목표 크기에 대한 문자열 조합 갯수 비교를 위해, 저장&lt;/p&gt;
&lt;p&gt;결과 반환을 위해 도출한 부분 문자열 정렬 후 반환을 해야한다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;코드-설명&#34;&gt;코드 설명&lt;/h2&gt;
&lt;p&gt;풀이 작성시 핵심이 되는 부분 문자열 생성메소드 부분이다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;create&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;String str&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; cnt&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; target&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; idx&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; order&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 목표 길이에 맞는지 확인		
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;cnt &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 결과로 나온 부분 문자열 내부를 알파벳 순에 맞춰 정렬하여 반환 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; foods &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; courseOrderingByAlphabet&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;str&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;			
        &lt;span style=&#34;color:#75715e&#34;&gt;// 정렬을 위해 char[] 로 나온 결과를 다시 스트링 값으로 변경
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        String newCourse &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; createCourseName&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;foods&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 부분 문자열 마다 카운팅을 위해, map객체에 저장.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; courseCnt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; map&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getOrDefault&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;newCourse&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;			
        map&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;put&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;newCourse&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; courseCnt&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 각 코스별 가장 많이 호출된 갯수 저장을 위해 저장.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        isMostFavoriteCourse&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;courseCnt&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; target&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;		
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 입력 문자열에 대해 순차적으로 더하여 부분 문자열 생성하며 진행
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; idx&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; order&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;			
        &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; food &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; order&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;];&lt;/span&gt;			
        create&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;str &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; food&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; cnt &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; target&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; order&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;		
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;	
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;문자열을 인덱스로 순회하며 문자열의 부분 문자열을 생성하는데, 깔끔하게 메소드를 만들지 못해 아쉽다.&lt;/p&gt;
&lt;p&gt;한 눈에 들어오는 편이 아니기 때문에 추가적인 설명을 남긴다.&lt;/p&gt;
&lt;p&gt;입력 문자열 예시로 &lt;code&gt;ABCDE&lt;/code&gt; 라는 문자열이 들어오고&lt;/p&gt;
&lt;p&gt;목표 부분 문자열 크기로 &lt;code&gt;2&lt;/code&gt; 라고 하자.&lt;/p&gt;
&lt;p&gt;해당 메소드로 처리를 위해, &lt;code&gt;ABCDE&lt;/code&gt; 문자열을 &lt;code&gt;index&lt;/code&gt;로 순회하며 메소드를 호출하게 된다.&lt;/p&gt;
&lt;p&gt;메소드의 파라미터를 여기서 정하였는데&lt;/p&gt;
&lt;p&gt;&lt;code&gt;str&lt;/code&gt; - 생성할 부분 문자열&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cnt&lt;/code&gt; - 부분 문자열 크기&lt;/p&gt;
&lt;p&gt;&lt;code&gt;targert&lt;/code&gt; - 목표 부분 문자열크기&lt;/p&gt;
&lt;p&gt;&lt;code&gt;idx&lt;/code&gt; - 입력 문자열에 대한 &lt;code&gt;index&lt;/code&gt; 로 각 문자별 생성을 위해 입력받음&lt;/p&gt;
&lt;p&gt;&lt;code&gt;order&lt;/code&gt; - 전체 문자열 &lt;code&gt;char[]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;보다 싶이 파라미터로 받는 변수가 많아, 정확히 어떤 값을 어떻게 처리하는지 바로 파악하는데 어려움이 따른다&amp;hellip;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;나중엔 이러지 말자&amp;hellip;&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;이후 들어온 문자열을 시작점부터 시작하여 부분 문자열을 생성한다.&lt;/p&gt;
&lt;p&gt;재귀 호출을 통해 생성하는데, 스트링 연산시 새로운 인스턴스가 새롭게 생성되므로&lt;/p&gt;
&lt;p&gt;첫 문자 &lt;code&gt;A&lt;/code&gt; -&amp;gt; 두번째 &lt;code&gt;B&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;첫 문자 &lt;code&gt;A&lt;/code&gt; -&amp;gt; 두번째 &lt;code&gt;C&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;와 같은 순서로 생성되어 문자열에 대한 부분 문자열을 생성하게 된다.&lt;/p&gt;
&lt;p&gt;문자열 크기가 목표 크기에 다다르게 되면, 해당 문자열을 각 문자로 분해후 정렬하여&lt;/p&gt;
&lt;p&gt;결과 도출시 문제가 없도록 한 후, 각 문자별 카운팅을 위해 저장한다.&lt;/p&gt;
&lt;p&gt;마음에 안드는 부분 투성이지만 여기까지&amp;hellip;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://programmers.co.kr/learn/courses/30/lessons/72411&#34;&gt;문제 링크&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tech.kakao.com/2021/01/25/2021-kakao-recruitment-round-1/&#34;&gt;공식 풀이&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>2018 카카오 블라인드   뉴스 클러스터링</title>
      <link>/algorithm/2018-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C-%EB%89%B4%EC%8A%A4-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81/</link>
      <pubDate>Mon, 07 Jun 2021 21:11:05 +0900</pubDate>
      
      <guid>/algorithm/2018-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C-%EB%89%B4%EC%8A%A4-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81/</guid>
      <description>간단히 문제를 요약하자면&amp;hellip;
두 문자열을 받아 영문자에 대한 자카르 유사도를 계산하기
정도로 요약이 되나, 세부적인 사항이 있다.
문제 풀이에 앞서 문제 및 요구사항 정리를 해보자
 입력값으로는 2자 이상 1000자 이하의 두 문자열을 입력 받음 입력값에 대한 자카르 유사도를 출력해야함 입력 문자열은 두 글자씩 끊어서 연산에 사용한다.  이 때, 기타 공백이나 숫자, 특수 문자가 포함될 경우 연산에 사용하지 않는다   대소문자 구별을 하지 않는다.  그렇다면 자카르 유사도 란 무엇일까?</description>
      <content>&lt;p&gt;간단히 문제를 요약하자면&amp;hellip;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;두 문자열을 받아 영문자에 대한 자카르 유사도를 계산하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;정도로 요약이 되나, 세부적인 사항이 있다.&lt;/p&gt;
&lt;p&gt;문제 풀이에 앞서 문제 및 요구사항 정리를 해보자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;입력값으로는 2자 이상 1000자 이하의 두 문자열을 입력 받음&lt;/li&gt;
&lt;li&gt;입력값에 대한 자카르 유사도를 출력해야함&lt;/li&gt;
&lt;li&gt;입력 문자열은 두 글자씩 끊어서 연산에 사용한다.
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;이 때, 기타 공백이나 숫자, 특수 문자가 포함될 경우 연산에 사용하지 않는다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;대소문자 구별을 하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그렇다면 &lt;code&gt;자카르 유사도&lt;/code&gt; 란 무엇일까?&lt;/p&gt;
&lt;h2 id=&#34;자카르-유사도&#34;&gt;자카르 유사도&lt;/h2&gt;
&lt;p&gt;두 집합 간의 유사도를 검사하느 여러 방법 중 하나로, 수학적 수식으로 표현하면 아래와 같다.&lt;/p&gt;
&lt;p&gt;$$J(A,B) = \frac {|A\cap B|}{|A\cup B|} = \frac {|A\cap B|} {|A| + |B| - |A\cap B| } $$&lt;/p&gt;
&lt;p&gt;교집합을 합집합으로 나눈 값이다.&lt;/p&gt;
&lt;p&gt;그렇다면, 문제에서 자카르 유사도를 어떻게 계산해야 될까?&lt;/p&gt;
&lt;p&gt;문제에서는 두 집합의 경우,&lt;/p&gt;
&lt;p&gt;입력으로 주어지는 두 문자열의 부분 집합으로&lt;/p&gt;
&lt;p&gt;각 문자열을 제약사항(두글자 단위로, 영문만 포함된 문자열)에 맞춰 &lt;strong&gt;중복을 허락&lt;/strong&gt; 하는 집합이다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;풀이&#34;&gt;풀이&lt;/h2&gt;
&lt;p&gt;먼저 &lt;code&gt;두 문자&lt;/code&gt; 로 이뤄진 부분집합을 다루기 위해 해당하는 객체를 선언을 해주었다&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PartStr&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; b&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PartStr&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; b&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; b&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#75715e&#34;&gt;// equals and hashcode 생략
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;다음으론 문자열을 &lt;code&gt;PartStr&lt;/code&gt; 부분 집합으로 변환하는 메소드를 작성하였는데&lt;/p&gt;
&lt;p&gt;간단하게 문자열을 순회하면서 다음 문자열까지 가져와 둘 다 영문자일 경우에만 부분집합에 추가하였다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; List&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PartStr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;strToCharSet&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;String str&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    List&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PartStr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;       &lt;span style=&#34;color:#75715e&#34;&gt;// 결과로 나올 부분 집합
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; str&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;toUpperCase&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;                        &lt;span style=&#34;color:#75715e&#34;&gt;// 대소문자를 무시하고 계산하기 위해 전부 대문자로 변환
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; str&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;++)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; str&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;charAt&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; str&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;charAt&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(!&lt;/span&gt;isLetter&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;isLetter&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;         &lt;span style=&#34;color:#75715e&#34;&gt;// Character.isLetter 메소드를 사용하여 검사하였음
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        result&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; PartStr&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; b&lt;span style=&#34;color:#f92672&#34;&gt;));&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이제 두 집합을 추출하였으니, 자카르 유사도를 검사를 해야 한다.&lt;/p&gt;
&lt;p&gt;처음 작성시에는 중복 여부에 따른 값 변화를 깊게 생각하질 않아서,&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Stream&lt;/code&gt; 연산을 통해 곂치는 값만 카운팅을 해주었으나,&lt;/p&gt;
&lt;p&gt;중복을 허용하는 집합이기에 다르게 처리를 하였다.&lt;/p&gt;
&lt;p&gt;한 집합(A)에 대해서 순차적으로 확인 후(교집합) 다른 집합(B) 에서 제거하는 형식으로 진행하였다.&lt;/p&gt;
&lt;p&gt;합집합의 경우 $ |A| + |B| - |A\cap B| $ 이기에&lt;/p&gt;
&lt;p&gt;교집합 연산시 처리되지 않는 요소(A)와 제거되지 않은 요소(B)를 모두 더하면 자동으로 나온다.&lt;/p&gt;
&lt;p&gt;그리고 소숫점 5자리까지는 정확히 계산하기 위해 &lt;code&gt;BigDecimal&lt;/code&gt;을 통해 연산을 진행하였다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;float&lt;/code&gt; 를 사용할시 부정확하게 연산될 가능성이 있기에&lt;/p&gt;
&lt;p&gt;&lt;code&gt;double&lt;/code&gt; 이나 &lt;code&gt;BigDecimal&lt;/code&gt; 을 통해 연산을 하는게 좋아보인다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;jaccard&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PartStr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; partStrs1&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; Collection&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PartStr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; partStrs2&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;//교집합
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    List&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PartStr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; intersection &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 교집합으로 나올 집합
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//합집합
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    List&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PartStr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; union &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 합집합으로 나올 결과
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;PartStr elem &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; partStrs1&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;partStrs2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;contains&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;elem&lt;span style=&#34;color:#f92672&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
            intersection&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;elem&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
            partStrs2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;remove&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;elem&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
        union&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;elem&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
    union&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;addAll&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;partStrs2&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
    
    BigDecimal intersectionCount &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 
        BigDecimal&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;valueOf&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;intersection&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;());&lt;/span&gt;
    BigDecimal unionCount 
        &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; BigDecimal&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;valueOf&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;union&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;());&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; intersectionCount
            &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;divide&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;unionCount&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; 5&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; RoundingMode&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;FLOOR&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
            &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;floatValue&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;Exception e&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#75715e&#34;&gt;// 0으로 나뉘는 경우나 연산을 할 수 없는 경우, 문제 내용에 따라 1을 반환하였다.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; 1L&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt; 
    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h3 id=&#34;참고&#34;&gt;참고&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://programmers.co.kr/learn/courses/30/lessons/17677&#34;&gt;문제 링크&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/algorithm/blob/main/programmers30_17677/src/main/java/study/problem/Solution.java&#34;&gt;풀이 코드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
  </channel>
</rss>

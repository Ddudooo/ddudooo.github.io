<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>디자인패턴 on 공부한 내용 기록용</title>
    <link>/tags/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/</link>
    <description>Recent content in 디자인패턴 on 공부한 내용 기록용</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sat, 17 Jul 2021 17:22:02 +0900</lastBuildDate><atom:link href="/tags/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>프록시 패턴</title>
      <link>/programming/design-pattern/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Sat, 17 Jul 2021 17:22:02 +0900</pubDate>
      
      <guid>/programming/design-pattern/%ED%94%84%EB%A1%9D%EC%8B%9C-%ED%8C%A8%ED%84%B4/</guid>
      <description>프록시 패턴이란?  어떤 객체에 대한 접근을 제어하는 용도로 대리인이나 대변인에 해당하는 객체를 제공하는 패턴
다른 객에 대한 접근 제어나 가상 객체로 실제 처리시에만 처리 가능하게 하는 패턴
 구조  Subject
Proxy와 RealSubject의 인터페이스 Proxy
클라이언트 요구를 처리할 수 있을 만큼 처리, 자신만으로 처리가 안될시 실 객체에 위임 RealSubject
실제 처리하는 객체  종류  원격 프록시
원격 객체에 대한 접근 제어가 가능합니다 가상 프록시 Virtual Proxy
객체의 생성비용이 많이 들어 미리 생성하기 힘든 객체에 대한 접근 및 생성시점 등을 제어합니다 보호 프록시 Protection Proxy</description>
      <content>&lt;h1 id=&#34;프록시-패턴이란&#34;&gt;프록시 패턴이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;어떤 객체에 대한 접근을 제어하는 용도로 대리인이나 대변인에 해당하는 객체를 제공하는 패턴&lt;/p&gt;
&lt;p&gt;다른 객에 대한 접근 제어나 가상 객체로 실제 처리시에만 처리 가능하게 하는 패턴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/proxy/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Proxy와 RealSubject의 인터페이스&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Proxy&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;클라이언트 요구를 처리할 수 있을 만큼 처리, 자신만으로 처리가 안될시 실 객체에 위임&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RealSubject&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;실제 처리하는 객체&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;종류&#34;&gt;종류&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;원격 프록시&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;원격 객체에 대한 접근 제어가 가능합니다&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;가상 프록시&lt;/code&gt; &lt;code&gt;Virtual Proxy&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;객체의 생성비용이 많이 들어 미리 생성하기 힘든 객체에 대한 접근 및 생성시점 등을 제어합니다&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;보호 프록시&lt;/code&gt; &lt;code&gt;Protection Proxy&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;객체에 따른 접근 권한을 제어해야하는 객체에 대한 접근을 제어할 수 있습니다&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;방화벽 프록시&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;일련의 네트워크 자원에 대한 접근을 제어함으로써 주 객체를 &lt;span class=&#34;tx-orange&#34;&gt;&lt;strong&gt;나쁜&lt;/strong&gt;&lt;/span&gt; 클라이언트들로부터 보호하는 역할을 합니다&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;스마트 레퍼런스 프록시&lt;/code&gt; &lt;code&gt;Smart Reference Proxy&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;주 객체가 참조될 때마다 추가 행동을 제공합니다&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;캐싱 프록시&lt;/code&gt; &lt;code&gt;Caching Proxy&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;비용이 많이 드는 작업의 결과를 임시로 저장 하고&lt;/sub&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;추후 여러 클라이언트에 저장된 결과를 실제 작업처리 대신 보여주고 자원을 절약하는 역할을 합니다&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;동기화 프록시&lt;/code&gt; &lt;code&gt;Synchronization Proxy&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;여러 스레드에서 주 객체에 접근하는 경우에 안전하게 작업을 처리할 수 있게 해줍니다&lt;/sub&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;주로 분산 환경에서 일련의 객체에 대한 동기화 된 접근을 제어해주는 자바 스페이스에서 쓰입니다&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;복잡도 숨김 프록시&lt;/code&gt; &lt;code&gt;Complexity Hiding Proxy&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;복잡한 클래스들의 집합에 대한 접근을 제어하고, 복잡도를 숨깁니다&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;지연 복사 프록시&lt;/code&gt; &lt;code&gt;Copy-On-Write Proxy&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;클라이언트에서 필요로 할 때까지 객체가 복사되는 것을 지연시킴으로써 객체의 복사를 제어합니다&lt;/sub&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;span class=&#34;tx-orange&#34;&gt;&lt;strong&gt;변형된 가상 프록시&lt;/strong&gt;&lt;/span&gt;라고 할 수 있으며 Java 5 의 CopyOnWriteArrayList 에서 쓰입니다&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;p&gt;실제 처리되는 로직이 비용이 클 경우&lt;/p&gt;
&lt;p&gt;처리 순서를 미뤄 효율적으로 대처할 수 있다.&lt;/p&gt;
&lt;p&gt;실제 처리하는 객체에 대해 앞서 처리과정을 거친 후 처리할 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;p&gt;추가적으로 객체가 생성되어, 오히려 성능이 저하될 수 있다.&lt;/p&gt;
&lt;p&gt;올바른 처리과정을 위해 스레드 처리 및 동기화 로직을 적절히 구사해야한다.&lt;/p&gt;
&lt;p&gt;시스템 자체의 코드 복잡도가 늘어난다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Java언어로 배우는 디자인 패턴 입문&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/proxy_pattern.htm&#34;&gt;tutorialspoint&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/display/SLS/Proxy+Pattern&#34;&gt;SLiPP::위키 - Proxy Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jdm.kr/blog/235&#34;&gt;JDM&amp;rsquo;s Blog::프록시 패턴(Proxy Pattern)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developside.tistory.com/80&#34;&gt;소스코드 요리사::프록시 패턴(proxy pattern) 이란?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>메멘토 패턴</title>
      <link>/programming/design-pattern/%EB%A9%94%EB%A9%98%ED%86%A0-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Fri, 16 Jul 2021 19:57:12 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EB%A9%94%EB%A9%98%ED%86%A0-%ED%8C%A8%ED%84%B4/</guid>
      <description>메멘토 패턴이란?  객체를 이전 상태로 되돌릴 수 있는 기능을 제공하는 패턴
객체의 상태를 이전 상태로 복원하려는 위치를 줄이기 위해 사용
 구조  Originator
저장하려는 객체 Memento
Originator의 특정 시점을 저장하는 객체 Caretaker
Memento의 보관 및 관리  장점 지정된 객체의 상태를 별도의 객체에 보관하여,
지정 객체와 별도의 라이프 사이클을 지니게 되어 비교적 안전하다
복구 기능 구현이 쉬운편
단점 상태를 저장하고 복구하는 기능 자체는 비용이 많이 소요될 수 있음</description>
      <content>&lt;h1 id=&#34;메멘토-패턴이란&#34;&gt;메멘토 패턴이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;객체를 이전 상태로 되돌릴 수 있는 기능을 제공하는 패턴&lt;/p&gt;
&lt;p&gt;객체의 상태를 이전 상태로 복원하려는 위치를 줄이기 위해 사용&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/memento/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Originator&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;저장하려는 객체&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Memento&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Originator의 특정 시점을 저장하는 객체&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Caretaker&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Memento의 보관 및 관리&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;p&gt;지정된 객체의 상태를 별도의 객체에 보관하여,&lt;br&gt;
지정 객체와 별도의 라이프 사이클을 지니게 되어 비교적 안전하다&lt;/p&gt;
&lt;p&gt;복구 기능 구현이 쉬운편&lt;/p&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;p&gt;상태를 저장하고 복구하는 기능 자체는 비용이 많이 소요될 수 있음&lt;/p&gt;
&lt;p&gt;객체를 시점에 따라 스냅샷 형식으로 저장해두기에 시스템의 자원에 영향을 미침&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Java언어로 배우는 디자인 패턴 입문&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/memento_pattern.htm&#34;&gt;tutorialspoint::Design Patterns - Memento Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.baeldung.com/java-memento-design-pattern&#34;&gt;Baeldung::Memento Design Pattern in Java&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>플라이웨이트 패턴</title>
      <link>/programming/design-pattern/%ED%94%8C%EB%9D%BC%EC%9D%B4%EC%9B%A8%EC%9D%B4%ED%8A%B8-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Fri, 16 Jul 2021 17:22:37 +0900</pubDate>
      
      <guid>/programming/design-pattern/%ED%94%8C%EB%9D%BC%EC%9D%B4%EC%9B%A8%EC%9D%B4%ED%8A%B8-%ED%8C%A8%ED%84%B4/</guid>
      <description>플라이웨이트 패턴이란?  동일하거나 유사한 객체들 사이에 가능한 많은 데이터를 서로 공유하여 사용하도록 하여 메모리 사용량을 최소화하는 패턴
주로 중복 생성 가능성이 높은 자원이나 자원 생성 비용은 크나 사용 빈도가 낮은 경우 사용하는 패턴이다
 구조  Flyweight
공유 자원을 갖는 객체 ConcreateFlyweight
Flyweight 구현체로 공유 상태에 대한 저장 공간 관리 및 확보  UnsharedConcreateFlyweight
공유하지 않는 구현체   FlyweightFactory
Flyweight 객체 생성 및 관리  장점 어플리케이션에 공유 자원을 갖는 객체가 많다면 자원을 절약할 수 있다.</description>
      <content>&lt;h1 id=&#34;플라이웨이트-패턴이란&#34;&gt;플라이웨이트 패턴이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;동일하거나 유사한 객체들 사이에 가능한 많은 데이터를 서로 공유하여 사용하도록 하여 메모리 사용량을 최소화하는 패턴&lt;/p&gt;
&lt;p&gt;주로 중복 생성 가능성이 높은 자원이나 자원 생성 비용은 크나 사용 빈도가 낮은 경우 사용하는 패턴이다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/flyweight/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Flyweight&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;공유 자원을 갖는 객체&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreateFlyweight&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Flyweight 구현체로 공유 상태에 대한 저장 공간 관리 및 확보&lt;/sub&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;UnsharedConcreateFlyweight&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;공유하지 않는 구현체&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FlyweightFactory&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Flyweight 객체 생성 및 관리&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;p&gt;어플리케이션에 공유 자원을 갖는 객체가 많다면 자원을 절약할 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;p&gt;공유 자원 호출시 존재하는 데이터 검색과 같은 비용이 발생한다.&lt;/p&gt;
&lt;p&gt;객체를 공유자원으로 다시 나눠서 구현하기에 비교적 코드가 복잡해진다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Java 언어로 배우는 디자인 패턴 입문&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://readystory.tistory.com/137&#34;&gt;준비된 개발자::[구조 패턴] 플라이웨이트 패턴(Flyweight Pattern) 이해 및 예제&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/flyweight_pattern.htm&#34;&gt;tutorialspoint::Design Patterns - Flyweight Pattern&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>중재자 패턴</title>
      <link>/programming/design-pattern/%EC%A4%91%EC%9E%AC%EC%9E%90-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Thu, 15 Jul 2021 21:06:27 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%A4%91%EC%9E%AC%EC%9E%90-%ED%8C%A8%ED%84%B4/</guid>
      <description>중재자 패턴이란?  클래스간 복잡한 로직을 캡슐화 하여 하나의 클래스에 위임하여 처리하는 패턴
M:N의 관계에서 M:1의 관계로 복잡도를 떨어뜨려 유지 보수 및 재사용의 확장성에 유리한 패턴
 구조  Mediator
Colleague 역할과 통신하여 조정을 실행하는 API  ConcreteMediator
Mediator 구현체   Colleague
Mediator 역할과 통신을 실행할 API  ConcreateColleague
Colleague 구현체    언제 사용할까? 복잡하게 얽힌 객체와 객체간에 관계를 풀어 줄때 주로 사용하게 된다.
프로그램을 작성하다 보면 상호작용을 해야하는 경우 객체들 간의 결합도가 증가하고 유연성이 떨어지는 경우가 발생하게 된다.</description>
      <content>&lt;h1 id=&#34;중재자-패턴이란&#34;&gt;중재자 패턴이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;클래스간 복잡한 로직을 캡슐화 하여 하나의 클래스에 위임하여 처리하는 패턴&lt;/p&gt;
&lt;p&gt;M:N의 관계에서 M:1의 관계로 복잡도를 떨어뜨려 유지 보수 및 재사용의 확장성에 유리한 패턴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/mediator/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Mediator&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Colleague 역할과 통신하여 조정을 실행하는 API&lt;/sub&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ConcreteMediator&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Mediator 구현체&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Colleague&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Mediator 역할과 통신을 실행할 API&lt;/sub&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ConcreateColleague&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Colleague 구현체&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;언제-사용할까&#34;&gt;언제 사용할까?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;복잡하게 얽힌 객체와 객체간에 관계를 풀어 줄때 주로 사용하게 된다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;프로그램을 작성하다 보면 상호작용을 해야하는 경우 객체들 간의 결합도가 증가하고 유연성이 떨어지는 경우가 발생하게 된다.&lt;/p&gt;
&lt;p&gt;이런 경우에&lt;/p&gt;
&lt;p&gt;이제 특정 개체가 명령을 내릴 필요가 있으면 중재자 개체에게 전달하기만 하면 되고,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;중재자는 해당 명령을 자신이 알고 있는 개체들 중에 적절한 개체에게 전달만 하면 된다.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;p&gt;시스템에서 관련된 기능을 하는 객체의 연결관계를 파악하기 쉬워진다.&lt;/p&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;p&gt;특정 로직에 맞춰져 있기에 재사용하기 힘들다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/mediator_pattern.htm&#34;&gt;tutorialspoint::Design Patterns - Mediator Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/display/SLS/Mediator&#34;&gt;SLiPP::위키 - Mediator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>퍼사드 패턴</title>
      <link>/programming/design-pattern/%ED%8D%BC%EC%82%AC%EB%93%9C-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Thu, 15 Jul 2021 18:35:43 +0900</pubDate>
      
      <guid>/programming/design-pattern/%ED%8D%BC%EC%82%AC%EB%93%9C-%ED%8C%A8%ED%84%B4/</guid>
      <description>퍼사드 패턴이란?  서브시스템의 일련의 인터페이스에 대한 통합된 인터페이스를 제공하는 패턴
퍼사드에서 고수준 인터페이스를 정의하기 때문에 서브시스템을 더 쉽게 사용할 수 있습니다.
 구조 왜 사용할까?   복잡한 서브 시스템을 단순하게 표현
  사용하는 클라이언트 입장에서 서브 시스템을 모두 알 필요 없어짐
  장점  서브 시스템간의 결합도가 낮아짐 사용하는 클라이언트에서 간결하게 파악할 수 있음  단점   서브 시스템을 호출하는 클래스를 새롭게 생성해야함
  구조가 좀 더 복잡해지고 관리가 어려워질 수 있음</description>
      <content>&lt;h1 id=&#34;퍼사드-패턴이란&#34;&gt;퍼사드 패턴이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;서브시스템의 일련의 인터페이스에 대한 통합된 인터페이스를 제공하는 패턴&lt;/p&gt;
&lt;p&gt;퍼사드에서 고수준 인터페이스를 정의하기 때문에 서브시스템을 더 쉽게 사용할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;구조&#34;&gt;구조&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/facade/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;왜-사용할까&#34;&gt;왜 사용할까?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;복잡한 서브 시스템을 단순하게 표현&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사용하는 클라이언트 입장에서 서브 시스템을 모두 알 필요 없어짐&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;서브 시스템간의 결합도가 낮아짐&lt;/li&gt;
&lt;li&gt;사용하는 클라이언트에서 간결하게 파악할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;서브 시스템을 호출하는 클래스를 새롭게 생성해야함&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;구조가 좀 더 복잡해지고 관리가 어려워질 수 있음&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;참조&#34;&gt;참조&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/display/SLS/Facade+Pattern&#34;&gt;SLiPP::위키&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/facade_pattern.htm&#34;&gt;tutorialspoint::Design Patterns - Facade Pattern&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>싱글톤 패턴</title>
      <link>/programming/design-pattern/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Thu, 15 Jul 2021 16:19:27 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4/</guid>
      <description>싱글톤 패턴이란?  객체가 여러번 호출되더라고 동일한 객체를 보장하는 패턴
 구조  Singleton
하나의 인스턴스만을 생성하는 책임이 있으며
getInstance 메서드를 통해 모든 클라이언트에게 동일한 인스턴스를 반환하는 작업을 수행한다.  장점   단일 객체를 사용하기에 메모리 낭비를 방지할 수 있다
  전역에서 하나의 객체를 사용하기에 데이터를 공유하기에 쉽다.
  문제점  멀티 쓰레드 상에서 안전하게 작성하기 힘들다 클래스 내부에서 객체를 생성하기에 테스트시 어렵다   참조  [Design Pattern] 싱글턴 패턴이란 tutorialspoint::Design Pattern - Singleton Pattern  </description>
      <content>&lt;h1 id=&#34;싱글톤-패턴이란&#34;&gt;싱글톤 패턴이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;객체가 여러번 호출되더라고 동일한 객체를 보장하는 패턴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/singleton/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Singleton&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;하나의 인스턴스만을 생성하는 책임이 있으며&lt;/sub&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;getInstance&lt;/code&gt; 메서드를 통해 모든 클라이언트에게 동일한 인스턴스를 반환하는 작업을 수행한다.&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;단일 객체를 사용하기에 메모리 낭비를 방지할 수 있다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;전역에서 하나의 객체를 사용하기에 데이터를 공유하기에 쉽다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;문제점&#34;&gt;문제점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;멀티 쓰레드 상에서 안전하게 작성하기 힘들다&lt;/li&gt;
&lt;li&gt;클래스 내부에서 객체를 생성하기에 테스트시 어렵다&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;참조&#34;&gt;참조&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gmlwjd9405.github.io/2018/07/06/singleton-pattern.html&#34;&gt;[Design Pattern] 싱글턴 패턴이란&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/singleton_pattern.htm&#34;&gt;tutorialspoint::Design Pattern - Singleton Pattern&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>이터레이터 패턴</title>
      <link>/programming/design-pattern/%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Wed, 14 Jul 2021 17:56:18 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/</guid>
      <description>이터레이터 패턴이란?  반복자를 사용하여 컨테이너를 가로지르며 컨테이너의 요소들에 접근하는 디자인 패턴으로
컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 수 있게 해주는 방법을 제공해 준다.
 구조  Aggreate
Iterator 객체를 생성하는 인터페이스 ConcreateAggreate
Iterator를 제공하는 인터페이스의 구현체 Iterator
원소를 순회 및 접근하는 인터페이스 ConcreateIterator
Iterator의 구현체  왜 사용할까? 이터레이터 패턴을 사용할 경우
아래와 같은 특성이 생기게 되는데
 집합체의 응집도가 높아진다 집합체 내부 구현을 숨길 수 있다.</description>
      <content>&lt;h1 id=&#34;이터레이터-패턴이란&#34;&gt;이터레이터 패턴이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;반복자를 사용하여 컨테이너를 가로지르며 컨테이너의 요소들에 접근하는 디자인 패턴으로&lt;/p&gt;
&lt;p&gt;컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 수 있게 해주는 방법을 제공해 준다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/iterator/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Aggreate&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Iterator 객체를 생성하는 인터페이스&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreateAggreate&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Iterator를 제공하는 인터페이스의 구현체&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;원소를 순회 및 접근하는 인터페이스&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreateIterator&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;Iterator의 구현체&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;왜-사용할까&#34;&gt;왜 사용할까?&lt;/h2&gt;
&lt;p&gt;이터레이터 패턴을 사용할 경우&lt;/p&gt;
&lt;p&gt;아래와 같은 특성이 생기게 되는데&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;집합체의 응집도가 높아진다&lt;/li&gt;
&lt;li&gt;집합체 내부 구현을 숨길 수 있다.&lt;/li&gt;
&lt;li&gt;집합체 내부 정보를 알필요 없이, 집합체의 모든 항목에 접근할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이러한 특성으로 인해 아래와 같은 목적 등으로 사용한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;집합체의 내부 구현을 보여주지 않고 접근을 허용하고 싶을때.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;집약체에 다양한 탐색 방법이 필요한 경우.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서로 다른 집합 구조에 대해서도 동일한 방법으로 접근하고 싶을 경우.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/behavioral/IteratorPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/pages/viewpage.action?pageId=30772665&#34;&gt;SLiPP::위키 - Iterator pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/iterator_pattern.htm&#34;&gt;tutorialspoint Design Patterns - Iterator Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jusungpark.tistory.com/25&#34;&gt;정리정리정리 - 이터레이터 패턴 (iterator pattern)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>데코레이터 패턴</title>
      <link>/programming/design-pattern/%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Tue, 13 Jul 2021 18:12:12 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4/</guid>
      <description>데코레이터 패턴이란?  객체의 결합을 통해, 기능을 동적으로 확장할 수 있게 해주는 패턴
서브 클래스의 생성 대신 데코레이터를 통해 클래스의 기능을 확장하여 제공
 구조  Component
클라이언트가 사용하는 객체
기본 기능과 추가기능의 집합체 Decorator
추가적으로 제공할 기능의 공통 인터페이스 ConcreateComponent
기본 기능을 구현할 객체 ConcreateDecorator
추가적으로 제공의 개별적인 기능의 구현체  언제 사용할까? 기능을 추가할 객체를 수정하지 않고 새로운 기능이나 책임을 추가할 때
조합으로 재활용하여 다른 곳에도 사용하고 싶을 때</description>
      <content>&lt;h1 id=&#34;데코레이터-패턴이란&#34;&gt;데코레이터 패턴이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;객체의 결합을 통해, 기능을 동적으로 확장할 수 있게 해주는 패턴&lt;/p&gt;
&lt;p&gt;서브 클래스의 생성 대신 데코레이터를 통해 클래스의 기능을 확장하여 제공&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/decorator/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Component&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;클라이언트가 사용하는 객체&lt;/sub&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;기본 기능과 추가기능의 집합체&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Decorator&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;추가적으로 제공할 기능의 공통 인터페이스&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreateComponent&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;기본 기능을 구현할 객체&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreateDecorator&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;추가적으로 제공의 개별적인 기능의 구현체&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;언제-사용할까&#34;&gt;언제 사용할까?&lt;/h2&gt;
&lt;p&gt;기능을 추가할 객체를 수정하지 않고 새로운 기능이나 책임을 추가할 때&lt;/p&gt;
&lt;p&gt;조합으로 재활용하여 다른 곳에도 사용하고 싶을 때&lt;/p&gt;
&lt;p&gt;서브 클래스를 만드는 것이 비효율적일 때&lt;/p&gt;
&lt;h2 id=&#34;추가적으로-고려할점&#34;&gt;추가적으로 고려할점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Component&lt;/code&gt;는 장식을 추가할 베이스가 되는 역할이므로 작고 가볍게 정의하도록 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가급적 인터페이스만을 정의한다.&lt;/li&gt;
&lt;li&gt;무언가 저장하는 변수는 정의하지 않는다.
&lt;sub class=&#34;tx-sub&#34;&gt;(상속받는 여러 Decorator도 같이 복잡하고 무거워진다).&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;저장할 것이 있다면 서브클래스에서 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;상속 구조를 통해 &lt;code&gt;Decorator&lt;/code&gt;와 &lt;code&gt;Component&lt;/code&gt;가 같은 인터페이스를 갖게 해야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;투과적 인터페이스: &lt;code&gt;Decorator&lt;/code&gt;로 계속해서 감싸도 &lt;code&gt;Component&lt;/code&gt;의 메소드는 계속 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;코드를 수정하지 않고도 준비된 &lt;code&gt;Decorator&lt;/code&gt;을 조합해 기능을 추가할 수 있도록 생각해서 구현한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;비슷한 성질의 작은 클래스가 많이 만들어질 수 있다는 단점을 고려한다.
구현하려는 내용이 객체의 겉을 변경하려는 것인지, 속을 변경하려는 것인지 생각해 보자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;속을 변경하려는 것이라면 &lt;code&gt;strategy-pattern&lt;/code&gt;을 선택하는 것이 더 적절할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데코레이터 패턴으로 구현한 다음, 사용이 까다롭게 느껴지거나 자주 쓰는 조합이 있다면 다음 패턴을 사용해 제공하는 것을 고려해 보자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;builder-pattern&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;factory-pattern&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static-factory-method-pattern&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Decorator&lt;/code&gt;가 다른 &lt;code&gt;Decorator&lt;/code&gt;에 대해 알아야 할 필요가 있다면, 데코레이터 패턴의 사용 의도와 어긋나는 작업일 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;재귀적으로 기능을 갖게 하는 방법 외에도, &lt;code&gt;Decorator&lt;/code&gt;를 추가할 때마다 얻은 아이템을 &lt;code&gt;List&lt;/code&gt;로 관리하는 방법도 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;참조&#34;&gt;참조&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://johngrib.github.io/wiki/decorator-pattern&#34;&gt;기계인간 John Grib :: 데코레이터 패턴&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/decorator_pattern.htm&#34;&gt;Tutorialspoint :: Design Patterns - Decorator Pattern&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>프로토타입 패턴</title>
      <link>/programming/design-pattern/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 12 Jul 2021 18:36:41 +0900</pubDate>
      
      <guid>/programming/design-pattern/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%ED%8C%A8%ED%84%B4/</guid>
      <description>프로토 타입 패턴이란?  원형이 되는 인스턴스로 새로운 객체 종류를 명시하고
객체를 복사하여 새로운 객체를 생성하는 패턴
 구조도 Prototype - 복제 자체에 대한 인터페이스를 선언합니다.
ConcretePrototype - 복제 자체에 대한 작업을 구현합니다.
Client - 프로토타입을 복제하도록 요청하여 새 개체를 만듭니다.
왜 사용할까? 이점은? 객체 생성시에 비용이 크게 드는 경우.
객체의 각 부분을 조합해서 생성하는 형태에도 적용이 가능하기에 비교적 간단하게 객체를 생성할 수 있다.
유의사항 프로토타입 패턴을 구현시에 복사하는 연산, clone() 메소드에 대한 구현인데</description>
      <content>&lt;h1 id=&#34;프로토-타입-패턴이란&#34;&gt;프로토 타입 패턴이란?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;원형이 되는 인스턴스로 새로운 객체 종류를 명시하고&lt;/p&gt;
&lt;p&gt;객체를 복사하여 새로운 객체를 생성하는 패턴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조도&#34;&gt;구조도&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/prototype/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Prototype&lt;/code&gt; - 복제 자체에 대한 인터페이스를 선언합니다.&lt;br&gt;
&lt;code&gt;ConcretePrototype&lt;/code&gt; - 복제 자체에 대한 작업을 구현합니다.&lt;br&gt;
&lt;code&gt;Client&lt;/code&gt; - 프로토타입을 복제하도록 요청하여 새 개체를 만듭니다.&lt;/p&gt;
&lt;h2 id=&#34;왜-사용할까-이점은&#34;&gt;왜 사용할까? 이점은?&lt;/h2&gt;
&lt;p&gt;객체 생성시에 비용이 크게 드는 경우.&lt;/p&gt;
&lt;p&gt;객체의 각 부분을 조합해서 생성하는 형태에도 적용이 가능하기에 비교적 간단하게 객체를 생성할 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;유의사항&#34;&gt;유의사항&lt;/h2&gt;
&lt;p&gt;프로토타입 패턴을 구현시에 복사하는 연산, &lt;code&gt;clone()&lt;/code&gt; 메소드에 대한 구현인데&lt;/p&gt;
&lt;p&gt;얕은 복사와 깊은 복사에 대한 문제가 있다&lt;/p&gt;
&lt;p&gt;인스턴스 변수까지 복사하는지 변수를 공유하는지 대한 문제.&lt;/p&gt;
&lt;h3 id=&#34;얕은-복사-깊은-복사&#34;&gt;얕은 복사, 깊은 복사&lt;/h3&gt;
&lt;p&gt;얕은 복사[&lt;code&gt;Shallow Copy&lt;/code&gt;], 깊은 복사[&lt;code&gt;Deep Copy&lt;/code&gt;]에 대해 간단히 알아보자&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;얕은 복사의 경우&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체를 복사시에 해당 객체만 복사하여 새 객체를 생성한다.&lt;/li&gt;
&lt;li&gt;원본의 참조값만 복사하여.&lt;br&gt;
인스턴스의 변수는 원본, 복사본 모두 같은 값을 바라보게 된다.
&lt;ul&gt;
&lt;li&gt;바라보는 변수값이 변경되면 원본, 복사본 모두 변경된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;깊은 복사의 경우&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체를 복사 할 때, 해당 객체와 인스턴스 변수까지 복사하는 방식.&lt;/li&gt;
&lt;li&gt;참조는 공유하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;참고&#34;&gt;참고&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/pages/viewpage.action?pageId=30771915&#34;&gt;SLiPP::위키 Prototype Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.baeldung.com/java-pattern-prototype&#34;&gt;Baeldung::Prototype Pattern in Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/design_pattern/prototype_pattern.htm&#34;&gt;Tutorialspoint::Design Patterns - Prototype Pattern&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>인터프리터 패턴</title>
      <link>/programming/design-pattern/%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 05 Jul 2021 19:49:09 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%ED%8C%A8%ED%84%B4/</guid>
      <description>인터프리터 패턴이란?  문법 규칙을 클래스화 한 구조로써, 일련의 규칙으로 정의된 언어를 해석하는 패턴
인터프리터 언어의 인터프리터와 같은 의미로 쓰임
 구조  Context
인터프리터가 구문해석을 실행하기 위한 정보를 제공. 문맥에 대한 정보를 모두 가지고 있음. AbstactExpression
공통 인터페이스 정의 TerminalExpression
해당 표현 이후에 그 이상 전개 되지 않는 표현. 코드상에서 해당 표현 이후에는 더 이상 다른 Expression 객체를 호출하지 않음. NonterminalExpression
이미 전개된 표현  장점  각 문법 규칙을 클래스로 표현하여 언어를 쉽게 구현 가능 언어의 변경이나 확장이 쉬운편 Visitor 패턴을 활용, 기존 Expression 구조의 변경 없이 새로운 종류의 해석을 정의할 수 있음  단점  문법 규칙의 갯수가 많아지면 시스템의 복잡도가 올라간다.</description>
      <content>&lt;h2 id=&#34;인터프리터-패턴이란&#34;&gt;인터프리터 패턴이란?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;문법 규칙을 클래스화 한 구조로써, 일련의 규칙으로 정의된 언어를 해석하는 패턴&lt;/p&gt;
&lt;p&gt;인터프리터 언어의 인터프리터와 같은 의미로 쓰임&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/interpreter/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Context&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;인터프리터가 구문해석을 실행하기 위한 정보를 제공. 문맥에 대한 정보를 모두 가지고 있음.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AbstactExpression&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;공통 인터페이스 정의&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TerminalExpression&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;해당 표현 이후에 그 이상 전개 되지 않는 표현.&lt;/br&gt; 코드상에서 해당 표현 이후에는 더 이상 다른 &lt;code&gt;Expression&lt;/code&gt; 객체를 호출하지 않음.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NonterminalExpression&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;이미 전개된 표현&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;각 문법 규칙을 클래스로 표현하여 언어를 쉽게 구현 가능&lt;/li&gt;
&lt;li&gt;언어의 변경이나 확장이 쉬운편&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Visitor&lt;/code&gt; 패턴을 활용, 기존 &lt;code&gt;Expression&lt;/code&gt; 구조의 변경 없이 새로운 종류의 해석을 정의할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;문법 규칙의 갯수가 많아지면 시스템의 복잡도가 올라간다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/display/SLS/Interpreter&#34;&gt;SLiPP::위키 Interpreter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.baeldung.com/java-interpreter-pattern&#34;&gt;Baeldung::Interpreter Design Pattern in Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/behavioral/InterpreterPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>컴포짓 패턴</title>
      <link>/programming/design-pattern/%EC%BB%B4%ED%8F%AC%EC%A7%93-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 05 Jul 2021 17:38:39 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%BB%B4%ED%8F%AC%EC%A7%93-%ED%8C%A8%ED%84%B4/</guid>
      <description>컴포짓 패턴이란?  개별 객체와 복합 객체를 동일하게 다룰 수 있도록 하는 패턴
여러 객체들로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루게 해주는 패턴
 구조  Component
모든 클래스에 해당하는 공통의 행동을 정의하고 구현. Composite
자식을 가지는 클래스를 구현함. 자식과 관련된 연산을 포함함. Leaf
구성 요소의 기본이 되는 객체를 정의함.  장점  단일 객체와 복합 객체를 구별하지 않고 동일하게 생각하여, 같은 객체군으로 묶어서 관리할 때 편리  단점  복합객체 내 구성 요소의 깊이 만큼, 코드 단위의 디버깅이 힘들어진다.</description>
      <content>&lt;h2 id=&#34;컴포짓-패턴이란&#34;&gt;컴포짓 패턴이란?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;개별 객체와 복합 객체를 동일하게 다룰 수 있도록 하는 패턴&lt;/p&gt;
&lt;p&gt;여러 객체들로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루게 해주는 패턴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/composite/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Component&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt; 모든 클래스에 해당하는 공통의 행동을 정의하고 구현.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Composite&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt; 자식을 가지는 클래스를 구현함. 자식과 관련된 연산을 포함함.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Leaf&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt; 구성 요소의 기본이 되는 객체를 정의함.&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;단일 객체와 복합 객체를 구별하지 않고 동일하게 생각하여, 같은 객체군으로 묶어서 관리할 때 편리&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;복합객체 내 구성 요소의 깊이 만큼, 코드 단위의 디버깅이 힘들어진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mygumi.tistory.com/343&#34;&gt;마이구미의 Hello World :: 컴포지트 패턴&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/structural/CompositePattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>팩토리 메소드 패턴</title>
      <link>/programming/design-pattern/%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%86%8C%EB%93%9C-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Tue, 29 Jun 2021 17:26:46 +0900</pubDate>
      
      <guid>/programming/design-pattern/%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%86%8C%EB%93%9C-%ED%8C%A8%ED%84%B4/</guid>
      <description>팩토리 메소드 패턴이란?  객체 생성을 캡슐화하는 패턴
자식(하위) 클래스가 어떤 객체를 생성할지를 결정하도록 하는 패턴
 구조 장점  객체의 자료형이 하위 클래스 의해서 결정되어 비교적 확장에 용이함 하위 클래스에서 객체를 생성할 때, 상위 클래스에서 그 객체에 대한 정확한 타입을 몰라도 됨 동일한 형태로 프로그래밍 가능함 확장성 있는 전체 프로젝트 구성 가능함 구상 클래스에 의존하지 않고 추상화된 것에 의존  단점  객체가 늘어날 때마다 하위 클래스 재정의로 인한 불필요한 많은 클래스 생성 가능성이 있음   참고  Head First Design Patterns SLiPP::위키 Factory Method Pattern 예제 소스  </description>
      <content>&lt;h2 id=&#34;팩토리-메소드-패턴이란&#34;&gt;팩토리 메소드 패턴이란?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;객체 생성을 캡슐화하는 패턴&lt;/p&gt;
&lt;p&gt;자식(하위) 클래스가 어떤 객체를 생성할지를 결정하도록 하는 패턴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/factoryMethod/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;객체의 자료형이 하위 클래스 의해서 결정되어 비교적 확장에 용이함&lt;/li&gt;
&lt;li&gt;하위 클래스에서 객체를 생성할 때, 상위 클래스에서 그 객체에 대한 정확한 타입을 몰라도 됨&lt;/li&gt;
&lt;li&gt;동일한 형태로 프로그래밍 가능함&lt;/li&gt;
&lt;li&gt;확장성 있는 전체 프로젝트 구성 가능함&lt;/li&gt;
&lt;li&gt;구상 클래스에 의존하지 않고 추상화된 것에 의존&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;객체가 늘어날 때마다 하위 클래스 재정의로 인한 불필요한 많은 클래스 생성 가능성이 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/display/SLS/Factory+Method+Pattern&#34;&gt;SLiPP::위키 Factory Method Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/creation/FactoryMethodPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>커맨드 패턴</title>
      <link>/programming/design-pattern/%EC%BB%A4%EB%A7%A8%EB%93%9C-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 28 Jun 2021 15:55:24 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%BB%A4%EB%A7%A8%EB%93%9C-%ED%8C%A8%ED%84%B4/</guid>
      <description>커맨드 패턴이란?  요청을 객체의 형태로 캡슐화하여 사용자가 보낸 요청을 나중에 이용할 수 있도록
매서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴
 HEAD FIRST DESIGN 에서&amp;hellip;  커맨드 객체는 일련의 행동을 특정 리시버하고 연결시킴으로써 요구 사항을 캡슐화한 것이라는 점을 이미 배웠습니다.
이렇게 하기 위해서 행동과 리시버를 한 객체에 집어넣고, execute()라는 메소드 하나만 외부에 공개하는 방법을 씁니다.
이 메소드 호출에 의해서 리시버에서 일련의 작업이 처리됩니다.</description>
      <content>&lt;h2 id=&#34;커맨드-패턴이란&#34;&gt;커맨드 패턴이란?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;요청을 객체의 형태로 캡슐화하여 사용자가 보낸 요청을 나중에 이용할 수 있도록&lt;/p&gt;
&lt;p&gt;매서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;head-first-design-에서&#34;&gt;HEAD FIRST DESIGN 에서&amp;hellip;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;커맨드 객체는 일련의 행동을 특정 리시버하고 연결시킴으로써 요구 사항을 캡슐화한 것이라는 점을 이미 배웠습니다.&lt;/p&gt;
&lt;p&gt;이렇게 하기 위해서 행동과 리시버를 한 객체에 집어넣고, execute()라는 메소드 하나만 외부에 공개하는 방법을 씁니다.&lt;/p&gt;
&lt;p&gt;이 메소드 호출에 의해서 리시버에서 일련의 작업이 처리됩니다.&lt;/p&gt;
&lt;p&gt;외부에서 볼 때는 어떤 객체가 리시버 역할을 하는지, 그 리시버에서 실제로 어떤 일을 하는지 알 수 없습니다.&lt;/p&gt;
&lt;p&gt;그냥 execute() 메소드를 호출하면 요구 사항이 처리된다는 것만 알 수 있을 뿐이죠.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/command/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Command&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;실행될 기능에 대한 인터페이스&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteCommand&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;실제로 실행되는 기능을 구현&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Invoker&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;기능의 실행을 요청하는 호출자 클래스&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;ConcreteCommand&lt;/code&gt;에서 &lt;code&gt;execute&lt;/code&gt; 메서드를 구현할 때 필요한 클래스&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;작업을 요청하는 클래스와 실제로 작업을 수행하는 클래스를 분리하여 시스템의 결합도를 낮출 수 있음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;기존 코드를 수정하지 않고 새로운 기능을 비교적 쉽게 추가할 수 있음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;동작자체를 객체화하여 일련의 트랜잭션을 객체단위로 제공할 수 있음&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;구현 및 유지보수해야 하는 클래스가 많아지게 됨.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://johngrib.github.io/wiki/command-pattern/&#34;&gt;기계인간 John Grib Command Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/behavioral/CommandPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>브릿지 패턴</title>
      <link>/programming/design-pattern/%EB%B8%8C%EB%A6%BF%EC%A7%80-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Fri, 25 Jun 2021 17:17:15 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EB%B8%8C%EB%A6%BF%EC%A7%80-%ED%8C%A8%ED%84%B4/</guid>
      <description>브릿지 패턴이란?  구현부와 추상층을 분리한 패턴
구현 뿐만 아니라 추상화 부분까지 변경시켜야 하는 경우에 사용하는 구조적 디자인 패턴.
 구조  Abstraction 추상화된 인터페이스 RefinedAbstraction 정의된 인터페이스를 확장하는 객체 Implementor 구현 클래스의 인터페이스를 정의
Abstraction의 인터페이스와 일치 할 필요는 없다. ConcreteImplementor Implementor의 인터페이스를 구현하고 구체적인 구현한 객체  장점  구현을 인터페이스에 완전히 결합시키지 않음
-&amp;gt; 구현과 추상화된 부분을 분리시킬 수 있음. 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있음 추상화된 부분을 구현한 구상 클래스를 바꿔도 클라이언트에 영향을 끼치지 않음  단점  디자인이 복잡해짐   참고  Head First Design Patterns SLiPP::위키 Bridge Pattern 예제 소스  </description>
      <content>&lt;h2 id=&#34;브릿지-패턴이란&#34;&gt;브릿지 패턴이란?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;구현부와 추상층을 분리한 패턴&lt;/p&gt;
&lt;p&gt;구현 뿐만 아니라 추상화 부분까지 변경시켜야 하는 경우에 사용하는 구조적 디자인 패턴.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/bridge/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Abstraction&lt;/code&gt;
추상화된 인터페이스&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RefinedAbstraction&lt;/code&gt;
정의된 인터페이스를 확장하는 객체&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Implementor&lt;/code&gt;
구현 클래스의 인터페이스를 정의&lt;br&gt;
&lt;code&gt;Abstraction&lt;/code&gt;의 인터페이스와 일치 할 필요는 없다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteImplementor&lt;/code&gt;
&lt;code&gt;Implementor&lt;/code&gt;의 인터페이스를 구현하고 구체적인 구현한 객체&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;구현을 인터페이스에 완전히 결합시키지 않음&lt;br&gt;
-&amp;gt; 구현과 추상화된 부분을 분리시킬 수 있음.&lt;/li&gt;
&lt;li&gt;추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있음&lt;/li&gt;
&lt;li&gt;추상화된 부분을 구현한 구상 클래스를 바꿔도 클라이언트에 영향을 끼치지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;디자인이 복잡해짐&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slipp.net/wiki/display/SLS/Bridge+Pattern&#34;&gt;SLiPP::위키 Bridge Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/structural/BridgePattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>빌더 패턴</title>
      <link>/programming/design-pattern/%EB%B9%8C%EB%8D%94-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Thu, 24 Jun 2021 20:44:04 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EB%B9%8C%EB%8D%94-%ED%8C%A8%ED%84%B4/</guid>
      <description>구조  Builder
Prouduct 객체의 요소들을 생성하기 위한 추상 인터페이스를 정의 ConcreateBuilder
Builder에서 정의해둔 인터페이스를 구현 Director
Builder 인터페이스를 사용하는 객체를 합성 Product
빌더패턴을 이용하여 생성된 인스턴스  왜 사용해야 할까?  빌드 패턴은 객체를 생성하는 작업을 분할 하는 데 도움이 된다 ‎일반적으로 복잡한 만들기 논리를 캡슐화할 수 있다 여러 단계와 절차를 통해 객체가 생성된다.
각 단계 및 절차 별로 독립적인 추상화나 관리를 할 수 있음 물체는 준비가되기 전에 일부 지시된 단계에 의해 관리되어야하며 다른 클라이언트가 사용할 수 있다 ‎ 클라이언트 측에서는 추상 인터페이스만 바라보기에 구현 코드를 쉽게 바꿀 수 있다  이펙티브 자바 - 빌더 패턴 일반적으로 빌더 라고 하면 이쪽을 많이 부른다.</description>
      <content>&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/builder/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Builder&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;Prouduct&lt;/code&gt; 객체의 요소들을 생성하기 위한 추상 인터페이스를 정의&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreateBuilder&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;Builder&lt;/code&gt;에서 정의해둔 인터페이스를 구현&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Director&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;Builder&lt;/code&gt; 인터페이스를 사용하는 객체를 합성&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Product&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;빌더패턴을 이용하여 생성된 인스턴스&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;왜-사용해야-할까&#34;&gt;왜 사용해야 할까?&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;빌드 패턴은 객체를 생성하는 작업을 분할 하는 데 도움이 된다&lt;/li&gt;
&lt;li&gt;‎일반적으로 복잡한 만들기 논리를 캡슐화할 수 있다&lt;/li&gt;
&lt;li&gt;여러 단계와 절차를 통해 객체가 생성된다.&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;각 단계 및 절차 별로 독립적인 추상화나 관리를 할 수 있음&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;물체는 준비가되기 전에 일부 지시된 단계에 의해 관리되어야하며 다른 클라이언트가 사용할 수 있다 ‎&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;클라이언트 측에서는 추상 인터페이스만 바라보기에 구현 코드를 쉽게 바꿀 수 있다&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;이펙티브-자바---빌더-패턴&#34;&gt;이펙티브 자바 - 빌더 패턴&lt;/h2&gt;
&lt;p&gt;일반적으로 &lt;code&gt;빌더&lt;/code&gt; 라고 하면 이쪽을 많이 부른다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;생성자에 매개변수가 많다면 빌더를 고려하라&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;객체 생성하는 몇가지 패턴이 존재하는데&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;점층적 생성자 패턴&lt;/li&gt;
&lt;li&gt;자바빈 패턴&lt;/li&gt;
&lt;li&gt;빌더 패턴&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;그 중 하나인 빌더 패턴이다&lt;/p&gt;
&lt;p&gt;해당 내용에 대한 글이 아니기에 언급만하고 생략&amp;hellip;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://johngrib.github.io/wiki/builder-pattern/#gof-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4%EC%9D%98-%EB%B9%8C%EB%8D%94-%ED%8C%A8%ED%84%B4&#34;&gt;빌더 패턴&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/creation/BuilderPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>책임 연쇄 패턴</title>
      <link>/programming/design-pattern/%EC%B1%85%EC%9E%84-%EC%97%B0%EC%87%84-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Thu, 24 Jun 2021 15:22:20 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%B1%85%EC%9E%84-%EC%97%B0%EC%87%84-%ED%8C%A8%ED%84%B4/</guid>
      <description>구조도   Handler 요청을 수신하고 처리객체들의 집합에 전달하는 인터페이스
집합의 첫 번째 핸들러에 대한 정보만 가지고 있음
  Concrete handlers 요청을 처리하는 객체
  Client 요청을 전달하는 클라이언트
  책임 연쇄 패턴이란? 명령 객체와 일련의 처리 객체를 포함하는 패턴으로
각각의 처리 객체는 명령 객체를 처리할 수 있는 연산의 집합이고
체인 안의 처리 객체가 핸들할 수 없는 명령은 다음 처리 객체로 넘겨지며 처리된다.
장점  요청을 보낸 쪽하고 받는 쪽을 분리시킬 수 있다 객체에는 사슬의 구조를 몰라도 되고 그 사슬에 들어있는</description>
      <content>&lt;h2 id=&#34;구조도&#34;&gt;구조도&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/chain-of-responsibility/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Handler&lt;/code&gt; 요청을 수신하고 처리객체들의 집합에 전달하는 인터페이스&lt;br&gt;
집합의 첫 번째 핸들러에 대한 정보만 가지고 있음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Concrete handlers&lt;/code&gt; 요청을 처리하는 객체&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Client&lt;/code&gt; 요청을 전달하는 클라이언트&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;책임-연쇄-패턴이란&#34;&gt;책임 연쇄 패턴이란?&lt;/h2&gt;
&lt;p&gt;명령 객체와 일련의 처리 객체를 포함하는 패턴으로&lt;/p&gt;
&lt;p&gt;각각의 처리 객체는 명령 객체를 처리할 수 있는 연산의 집합이고&lt;/p&gt;
&lt;p&gt;체인 안의 처리 객체가 핸들할 수 없는 명령은 다음 처리 객체로 넘겨지며 처리된다.&lt;/p&gt;
&lt;h2 id=&#34;장점&#34;&gt;장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;요청을 보낸 쪽하고 받는 쪽을 분리시킬 수 있다&lt;/li&gt;
&lt;li&gt;객체에는 사슬의 구조를 몰라도 되고 그 사슬에 들어있는&lt;br&gt;
다른 객체에 대한 직접적인 레퍼런스를 가질 필요도 없기 때문에&lt;br&gt;
객체를 단순하게 만들 수 있다&lt;/li&gt;
&lt;li&gt;사슬에 들어가는 객체를 바꾸거나 순서를 바꿈으로써 역활을 동적으로 추가/제거할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단점&#34;&gt;단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;실행시 과정을 살펴보거나 디버깅하기 힘들 수 있음&lt;/li&gt;
&lt;li&gt;요청이 반드시 처리된다는 보장이 없음&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참조&#34;&gt;참조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/behavioral/ChainOfResponsibility&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>어댑터 패턴</title>
      <link>/programming/design-pattern/%EC%96%B4%EB%8C%91%ED%84%B0-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Wed, 23 Jun 2021 23:10:43 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%96%B4%EB%8C%91%ED%84%B0-%ED%8C%A8%ED%84%B4/</guid>
      <description>구조도 Client 라이브러리나 외부 시스템을 사용하려는 요소
Adaptee 사용될 라이브러리나 외부 시스템
Target 어댑터가 구현하는 인터페이스
클라이언트는 인터페이스를 통해 어댑터와 연결된 Adaptee를 사용하게 된다.
Adapter Client 와 Adaptee 중간에서 호환성이 없는 둘을 연결하는 역활
어댑터 패턴이란? 한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환합니다.
어댑터를 이용하면 인터페이스 호환성 문제 때문에
같이 쓸 수 없는 클래스를 연결해서 쓸 수 있음.
왜 사용해야 할까? 인터페이스 호환 문제로 같이 쓸 수 없을 경우 사용한다곤 하는데</description>
      <content>&lt;h2 id=&#34;구조도&#34;&gt;구조도&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/adapter/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Client&lt;/code&gt; 라이브러리나 외부 시스템을 사용하려는 요소&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Adaptee&lt;/code&gt; 사용될 라이브러리나 외부 시스템&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Target&lt;/code&gt; 어댑터가 구현하는 인터페이스&lt;/p&gt;
&lt;p&gt;클라이언트는 인터페이스를 통해 어댑터와 연결된 &lt;code&gt;Adaptee&lt;/code&gt;를 사용하게 된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Adapter&lt;/code&gt; &lt;code&gt;Client&lt;/code&gt; 와 &lt;code&gt;Adaptee&lt;/code&gt; 중간에서 호환성이 없는 둘을 연결하는 역활&lt;/p&gt;
&lt;h2 id=&#34;어댑터-패턴이란&#34;&gt;어댑터 패턴이란?&lt;/h2&gt;
&lt;p&gt;한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환합니다.&lt;/p&gt;
&lt;p&gt;어댑터를 이용하면 인터페이스 호환성 문제 때문에&lt;/p&gt;
&lt;p&gt;같이 쓸 수 없는 클래스를 연결해서 쓸 수 있음.&lt;/p&gt;
&lt;h2 id=&#34;왜-사용해야-할까&#34;&gt;왜 사용해야 할까?&lt;/h2&gt;
&lt;p&gt;인터페이스 호환 문제로 같이 쓸 수 없을 경우 사용한다곤 하는데&lt;/p&gt;
&lt;p&gt;왜 써야할까?&lt;/p&gt;
&lt;p&gt;단순하게 사용할 수 있게 수정하면 되지 않을까?&lt;/p&gt;
&lt;h3 id=&#34;__어댑티-쪽을-수정한다고-가정하면__&#34;&gt;&lt;strong&gt;어댑티 쪽을 수정한다고 가정하면&amp;hellip;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;어댑티가 제공받은 라이브러리로써 직접적으로 수정이 불가능할 경우에 문제가 생길 수 있다.&lt;/p&gt;
&lt;p&gt;수정이 가능할 경우 이후 어댑티가 제공자에 의해 수정되는 경우&lt;/p&gt;
&lt;p&gt;해당 수정내용을 반영한 어댑티를 다시 수정해야 한다..&lt;/p&gt;
&lt;h3 id=&#34;__그렇다면-클라이언트-쪽은-어떨까__&#34;&gt;&lt;strong&gt;그렇다면 클라이언트 쪽은 어떨까&amp;hellip;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;클라이언트의 경우 단순한 구조라면 별 문제가 발생하지 않지만&lt;/p&gt;
&lt;p&gt;구조가 복잡해지거나 클라이언트의 연관관계가 많아질 경우&lt;/p&gt;
&lt;p&gt;클라이언트 수정시 다른 곳에서 문제가 발생할 수 있다&lt;/p&gt;
&lt;h3 id=&#34;요약하자면&#34;&gt;요약하자면&lt;/h3&gt;
&lt;p&gt;클라이언트와 어댑티를 수정하지 않고도 사용할 수 있게 해주는 패턴으로&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;수정시 발생할 수 있는 사이드 이펙트를 막게 해준다.&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참조&#34;&gt;참조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/structural/AdapterPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>추상 팩토리 패턴</title>
      <link>/programming/design-pattern/%EC%B6%94%EC%83%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Tue, 22 Jun 2021 16:16:12 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EC%B6%94%EC%83%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%8C%A8%ED%84%B4/</guid>
      <description>구조도 추상 팩토리 패턴이란? 상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나
독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공하기 위해 사용.
 AbstractFactory
개념적 제품에 대한 객체를 생성하는 연산으로 인터페이스를 정의한다. ConcreteFactory
구체적인 제품에 대한 객체를 생성하는 연산을 구현한다. AbstractProduct
개념적 제품 객체에 대한 인터페이스를 정의한다. ConcreteProduct
구체적으로 팩토리가 생성할 객체를 정의하고, AbstractProduct가 정의하는 인터페이스를 구현한다. Client
AbstractFactory와 AbstractProduct 클래스에 선언된 인터페이스를 사용한다.  언제 사용해야 할까?  객체 생성과 객체를 사용하는 시스템을 독립적으로 구성하기 위해서.</description>
      <content>&lt;h2 id=&#34;구조도&#34;&gt;구조도&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/images/designPattern/abstractFactory/structure.png&#34; alt=&#34;structure.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;추상-팩토리-패턴이란&#34;&gt;추상 팩토리 패턴이란?&lt;/h2&gt;
&lt;p&gt;상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나&lt;/p&gt;
&lt;p&gt;독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공하기 위해 사용.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AbstractFactory&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;개념적 제품에 대한 객체를 생성하는 연산으로 인터페이스를 정의한다.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteFactory&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;구체적인 제품에 대한 객체를 생성하는 연산을 구현한다.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AbstractProduct&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;개념적 제품 객체에 대한 인터페이스를 정의한다.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteProduct&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;구체적으로 팩토리가 생성할 객체를 정의하고, &lt;code&gt;AbstractProduct&lt;/code&gt;가 정의하는 인터페이스를 구현한다.&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Client&lt;/code&gt;&lt;br&gt;
&lt;sub class=&#34;tx-sub&#34;&gt;&lt;code&gt;AbstractFactory&lt;/code&gt;와 &lt;code&gt;AbstractProduct&lt;/code&gt; 클래스에 선언된 인터페이스를 사용한다.&lt;/sub&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;언제-사용해야-할까&#34;&gt;언제 사용해야 할까?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;객체 생성과 객체를 사용하는 시스템을 독립적으로 구성하기 위해서.&lt;/li&gt;
&lt;li&gt;여러 객체 군을 시스템이 사용하기 위해,
다른것으로도 대체를 쉽게 하기 위해서.&lt;/li&gt;
&lt;li&gt;여러 객체 군을 함께 사용할 수 있어야 할때.&lt;/li&gt;
&lt;li&gt;제품에 대한 클래스 라이브러리를 세부 정보를 노출없이 제공하고 싶을 때
&lt;ul&gt;
&lt;li&gt;클래스의 구현으로 제공이 아닌 인터페이스만 노출시키고 싶을 경우.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여러 팩토리에서 객체를 생산하며,&lt;/p&gt;
&lt;p&gt;생산된 객체가 무엇인지 몰라도 객체의 인터페이스만으로도 조작할 수 있음.&lt;/p&gt;
&lt;p&gt;객체를 조합으로 생성할 경우, 유용하게 사용할 수 있을듯하다.&lt;/p&gt;
&lt;p&gt;다만, 패턴 생성시 보일러 플레이트가 한두개가 아닌데.&lt;/p&gt;
&lt;p&gt;인터페이스 수정, 추상 메소드의 추가와 같은 수정사항이 생기는 경우&amp;hellip;&lt;/p&gt;
&lt;p&gt;고민을 좀 해봐야 할듯&amp;hellip;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참조&#34;&gt;참조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Head First Design Patterns&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://johngrib.github.io/wiki/abstract-factory-pattern/&#34;&gt;기계인간 - Abstract Factory Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Ddudooo/designpattern/tree/main/creation/AbstractFactoryPattern&#34;&gt;예제 소스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>디자인 패턴</title>
      <link>/programming/design-pattern/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 21 Jun 2021 17:12:33 +0900</pubDate>
      
      <guid>/programming/design-pattern/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/</guid>
      <description>디자인패턴이란? 앞선 개발자들이 만들어 놓은 공통적으로 발생하는 문제에 대한 재사용 가능한 해결책 이다.
일반적으로 디자인 패턴 이라고 한다면 Gang-Of-Four 가 쓴 디자인패턴 서적의 내용이라고 보면 된다.
&amp;ldquo;디자인패턴이란? 일반적인 문제를 해결하기 위한 문제해결책이다.&amp;rdquo;
이정도까지만 알고 있어도 문제없을듯하다.
그래서 왜 디자인 패턴을 알아야 하나?   앞서 말한것과 같이 일반적으로 발생하는 문제 의 해결책으로 사용할 수 있기 때문에
  다른 개발자와 소통하기 편해진다.
  1번의 경우 앞에서 나온 내용이기에 생략한다.</description>
      <content>&lt;h1 id=&#34;디자인패턴이란&#34;&gt;디자인패턴이란?&lt;/h1&gt;
&lt;p&gt;앞선 개발자들이 만들어 놓은 &lt;strong&gt;공통적으로 발생하는 문제에 대한 재사용 가능한 해결책&lt;/strong&gt; 이다.&lt;/p&gt;
&lt;p&gt;일반적으로 &lt;strong&gt;디자인 패턴&lt;/strong&gt; 이라고 한다면 &lt;code&gt;Gang-Of-Four&lt;/code&gt; 가 쓴 디자인패턴 서적의 내용이라고 보면 된다.&lt;/p&gt;
&lt;p&gt;&amp;ldquo;&lt;strong&gt;디자인패턴이란?  일반적인 문제를 해결하기 위한 문제해결책이다.&lt;/strong&gt;&amp;rdquo;&lt;/p&gt;
&lt;p&gt;이정도까지만 알고 있어도 문제없을듯하다.&lt;/p&gt;
&lt;h2 id=&#34;그래서-왜-디자인-패턴을-알아야-하나&#34;&gt;그래서 왜 디자인 패턴을 알아야 하나?&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;앞서 말한것과 같이 &lt;strong&gt;일반적으로 발생하는 문제&lt;/strong&gt; 의 해결책으로 사용할 수 있기 때문에&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다른 개발자와 소통하기 편해진다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1번의 경우 앞에서 나온 내용이기에 생략한다.&lt;/p&gt;
&lt;p&gt;2번의 경우, 다르게 생각하는 경우도 있겠지만&lt;/p&gt;
&lt;p&gt;디자인 패턴으로 소통을 한다면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;해당 패턴에 사용되는 장점, 단점 등 내포되는 내용을 포괄적으로 소통가능&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;장황하게 길어지는 설명을 단순한 단어로 처리할 수 있음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;좀 더 프로그램의 구조에 대해 살펴볼 수 있게 됨&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;등등&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이와 같은 장점들이 있다고 알려져 있다&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;좀-더-알아보자&#34;&gt;좀 더 알아보자&lt;/h2&gt;
&lt;p&gt;일반적으로 통용되는 디자인 패턴을 일컫는&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Gang-Of-Four&lt;/code&gt;의 디자인패턴에서는 여러가지 종류의 디자인 패턴을 소개하고 있다.&lt;/p&gt;
&lt;p&gt;각각의 패턴은 여러가지 종류로 그룹화할 수 있겠지만&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;        
        &lt;strong class=&#34;tx-royalblue&#34;&gt;생성 패턴(Creational Pattern)&lt;/strong&gt;&lt;/br&gt;
        &lt;sub class=&#34;tx-sub&#34;&gt;객체의 생성을 다루는 패턴&lt;/sub&gt;        
    &lt;/li&gt; 
    &lt;li&gt;
        &lt;strong class=&#34;tx-teal&#34;&gt;구조 패턴(Structural Pattern)&lt;/strong&gt;&lt;/br&gt;
        &lt;sub class=&#34;tx-sub&#34;&gt;객체의 구성을 다루는 패턴&lt;/sub&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;strong class=&#34;tx-orange&#34;&gt;행동 패턴(Behavioral Pattern)&lt;/strong&gt;&lt;/br&gt;
        &lt;sub class=&#34;tx-sub&#34;&gt;객체의 행동, 또는 객체 간의 상호작용을 다루는 패턴&lt;/sub&gt;
    &lt;/li&gt;
&lt;/ol&gt; 
일반적으로 사용되는 패턴들을 3가지로 구분하자면 다음과 같다
&lt;table style=&#34;text-align: center;&#34;&gt;
&lt;thead&gt;
    &lt;tr&gt;
        &lt;td&gt;
            &lt;strong class=&#34;tx-royalblue&#34;&gt;
                생성 패턴(Creational Pattern)
            &lt;/strong&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;strong class=&#34;tx-teal&#34;&gt;
            구조패턴(Structural Pattern)
            &lt;/strong&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;strong class=&#34;tx-orange&#34;&gt;
            행동 패턴(Behavioral Pattern)
            &lt;/strong&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
            &lt;span&gt;추상 팩토리 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Abstract Factory Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;어댑터 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Adapter Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;책임 연쇄 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Chain Of Responsibility&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
            &lt;span&gt;빌더 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Builder Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;브릿지 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Bridge Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;            
            &lt;span&gt;커맨드 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Command Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
            &lt;span&gt;팩토리 메소드 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Factory Method Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;컴포짓 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Composite Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;인터프리터 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Interpreter Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
            &lt;span&gt;프로토타입 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Prototype Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;데코레이터 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Decorator Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;이터레이터 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Iterator Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
            &lt;span&gt;싱글톤 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Singleton Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;퍼사드 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Facade Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;중재자 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Mediator Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;플라이웨이트 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Flyweight Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;메멘토 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Memento Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
            &lt;span&gt;프록시 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Proxy Pattern&lt;/sub&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;옵저버 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Observer Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;상태 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;State Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;전략 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Strategy Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;방문자 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Visitor Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td class=&#34;tx-royalblue&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-teal&#34;&gt;
        &lt;/td&gt;
        &lt;td class=&#34;tx-orange&#34;&gt;
            &lt;span&gt;템플릿 메소드 패턴&lt;/span&gt;
            &lt;/br&gt;
            &lt;sub class=&#34;tx-sub&#34;&gt;Template Method Pattern&lt;/sub&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;디자인 패턴이란 말그대로 패턴이기에 많은 패턴이 존재하기에&amp;hellip; 표기되지 않은 패턴이 있을 수 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;참조&#34;&gt;참조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yes24.com/Product/Goods/17525598&#34;&gt;GoF의 디자인패턴&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;amp;ejkGb=KOR&amp;amp;barcode=9788979143409&#34;&gt;Head First Design Patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
  </channel>
</rss>
